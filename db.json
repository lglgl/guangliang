{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/book/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/book/source/css/book.scss","path":"css/book.scss","modified":0,"renderable":1},{"_id":"themes/book/source/js/book.js","path":"js/book.js","modified":0,"renderable":1},{"_id":"themes/book/source/js/book-menu.js","path":"js/book-menu.js","modified":0,"renderable":1},{"_id":"themes/book/source/js/book-post.js","path":"js/book-post.js","modified":0,"renderable":1},{"_id":"themes/book/source/js/book-toc.js","path":"js/book-toc.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/高级算法/Kruskal算法.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720604777464},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1720447155442},{"_id":"source/home.md","hash":"f2d76677c0e11a66448a912f4024b9127321726e","modified":1720453816682},{"_id":"source/_posts/kk.md","hash":"09ca614dd59bb622eefd27b793080b00e75ad740","modified":1720517430652},{"_id":"source/menu.md","hash":"ff3ccacc3cff4943a2daa9eb4193954983e7b77a","modified":1720606255221},{"_id":"source/_posts/数字取证/考试内容.md","hash":"8ad2228d1124a45069fcf57537d87231898a043b","modified":1720852800759},{"_id":"source/_posts/高级算法/GreedyAlgorithm.md","hash":"89fd450b2019d2587839c60aebffc1ce815740e4","modified":1720785800580},{"_id":"source/_posts/高级算法/BFS.md","hash":"089cffb2a6ee9bb9b2586baa9c9a17ba3d4e9d9a","modified":1720606036856},{"_id":"source/_posts/高级算法/P-NP问题.md","hash":"6ab6e24f14fce38918505279ccbce0f91b9e688f","modified":1720606036874},{"_id":"source/_posts/高级算法/2019年题目.md","hash":"8b55c91c2f0b671d3ff974cf10c94458f4f9dc04","modified":1720606535708},{"_id":"source/_posts/高级算法/PrimJarnik算法.md","hash":"ed7740d9e744b8a6beb8c08964061bb85561445e","modified":1720780583243},{"_id":"source/_posts/高级算法/队栈.md","hash":"f6043aea395533eee6fbc5422e0012bf3cf03c44","modified":1720773518483},{"_id":"source/_posts/高级算法/高级算法目录.md","hash":"214d9bf46de62eab699d0775287c04b4f75f9d56","modified":1720606131419},{"_id":"source/_posts/高级算法/图论.md","hash":"7be90fc14c6399c848e77be6bfd6200e77eb5a6f","modified":1720774154489},{"_id":"themes/book/scripts/merge-configs.js","hash":"73d4d9c35cedfe4ed99c849c73fcee4012738a1c","modified":1720447350101},{"_id":"themes/book/scripts/render.js","hash":"0190cae64d12ac47b601b9fb0f1434a09c5ac168","modified":1720447350101},{"_id":"themes/book/_config.yml","hash":"e11501937dde2a71e36b7a27e37a2da87a869ee8","modified":1720447350098},{"_id":"themes/book/README.md","hash":"a8506b68e699aabf38beec0f4150d4dd1477f85d","modified":1720447350098},{"_id":"themes/book/layout/index.ejs","hash":"ce0892216ca0cd664796c873190d26f2430e4959","modified":1720447350100},{"_id":"themes/book/LICENSE","hash":"03157c4b6e91d27f69508dbdc62c09bc38fd78fc","modified":1720447350098},{"_id":"themes/book/layout/post.ejs","hash":"37ea12159553023f07d1f99815a5a9b82a9c3ef7","modified":1720447350101},{"_id":"themes/book/layout/tags.ejs","hash":"f2744252f6de3451c19d695f8f518c5a054f58b7","modified":1720447350101},{"_id":"themes/book/layout/archive.ejs","hash":"dec48c24f9f94a2ddd733f70a96fba0886f563e5","modified":1720447350100},{"_id":"themes/book/layout/categories.ejs","hash":"e3e1aa97b9a21f5bd85c4f0c56d79e7096eda48c","modified":1720447350100},{"_id":"themes/book/layout/_components/brand.ejs","hash":"a5272fbc584e7b89c0ccf205661e90f2c99354a1","modified":1720447350098},{"_id":"themes/book/layout/_components/menu.ejs","hash":"c2c0efd59fed898cb41ad6a0ec94c49aca3e7fea","modified":1720447350098},{"_id":"themes/book/layout/page.ejs","hash":"2e53811dda487a8faf75b3c3372fc8b8726d1f55","modified":1720447350101},{"_id":"themes/book/layout/_components/post-meta.ejs","hash":"243532bf3d848291cb191331910e97b9a6b40bfa","modified":1720447350099},{"_id":"themes/book/layout/layout.ejs","hash":"6b197a2edf59592f3061ea521fa216fef1a3b168","modified":1720447350100},{"_id":"themes/book/layout/_components/sidebar-toggle.ejs","hash":"53d6fc0e8bfb8f36942d2d7afcbb306dd0f89c31","modified":1720447350099},{"_id":"themes/book/layout/_components/toc.ejs","hash":"92259942c0cbe60ede9db992f7142206e93431f2","modified":1720447350099},{"_id":"themes/book/layout/_lib/comments.ejs","hash":"823afb4dcbee4e8b2258671aaf1332fed038774e","modified":1720447350099},{"_id":"themes/book/layout/_lib/google-analytics.ejs","hash":"8fac33b80001d1eba38ec7f35e9bd22d79705f43","modified":1720447350099},{"_id":"themes/book/layout/_lib/zooming-image.ejs","hash":"c9b2c4772bac30ca2a8939e6e305c9c9397d9003","modified":1720447350099},{"_id":"themes/book/layout/_partials/navbar.ejs","hash":"10eae8b5ed78e82a38b58d9525422f10b9be89cf","modified":1720447350100},{"_id":"themes/book/layout/_partials/post-info.ejs","hash":"d9ff5a91882a47ceb2144dcdccdd9b56191e4228","modified":1720447350100},{"_id":"themes/book/source/css/book.scss","hash":"cac0f32677c1e3ede2700a0dd02dec6aba6997cd","modified":1720447350104},{"_id":"themes/book/source/css/_variables.scss","hash":"1e24fa7f2467f06be7ab6d034a47ff2438384d51","modified":1720447350104},{"_id":"themes/book/source/js/book.js","hash":"c150427c7397aea35ad83624f8db8f4b19846bb6","modified":1720447350104},{"_id":"themes/book/source/js/book-menu.js","hash":"deebd62833f484c84e08357291ccc797c7544eb6","modified":1720447350104},{"_id":"themes/book/source/js/book-post.js","hash":"d239e79163ceb5a37c9274c0c83010eea80554d8","modified":1720447350104},{"_id":"themes/book/source/js/book-toc.js","hash":"fcbf2a88d9bab50dbd1337150a5909e8b9eecd13","modified":1720447350104},{"_id":"themes/book/source/css/_components/brand.scss","hash":"d6d944b2ce367bc67249dcb917c2a36df2c7d285","modified":1720447350102},{"_id":"themes/book/source/css/_components/comments.scss","hash":"1e5204db1a98e70ccb3027df8eb5a0fbfa3530c1","modified":1720447350102},{"_id":"themes/book/source/css/_components/menu.scss","hash":"0b9ba0d7f5df5f9a1a4321b9f5ede89fc92be0b4","modified":1720447350102},{"_id":"themes/book/source/css/_components/post-meta.scss","hash":"489673d51d470fc6c47c0c5e942fb027f6f9846b","modified":1720447350102},{"_id":"themes/book/source/css/_components/post.scss","hash":"ad6e61a4a7fa6259577dc34263be727a4afc8b03","modified":1720447350103},{"_id":"themes/book/source/css/_components/sidebar-toggle.scss","hash":"9f1d81d4e98c0c2f62a17512bbd7fbdff59d5bfc","modified":1720447350103},{"_id":"themes/book/source/css/_partials/book-sidebar.scss","hash":"3e4b1b06404b084df7cbc4a31cfaf7db3594e75c","modified":1720447350103},{"_id":"themes/book/layout/_partials/head.ejs","hash":"41fecd85cd1540c811937b4f9df5061d3df2207b","modified":1720453233490},{"_id":"themes/book/source/css/_components/toc.scss","hash":"30c6fa4a4d9ed70b43ac26bd869ac8f58e3e0214","modified":1720447350103},{"_id":"themes/book/source/css/_partials/book-archive.scss","hash":"c5ac27a8769860174af70d8111b2c2beee2921d6","modified":1720447350103},{"_id":"themes/book/source/css/_partials/book-content.scss","hash":"8e7a53eb11d87925d2bf940bb29ea5a9ea8a22f4","modified":1720447350103},{"_id":"themes/book/source/css/_partials/book-navbar.scss","hash":"c7311a76fc29a262ed03091661b4dea30d53d4f7","modified":1720447350103},{"_id":"themes/book/source/css/_components/highlight/highlight.scss","hash":"5d7851dec993537f0e32d0301bae70ac0ccbb52d","modified":1720447350102},{"_id":"themes/book/source/css/_components/highlight/diff.scss","hash":"e1a087d44e499beb05d0906b8a64fff62a7ba01d","modified":1720447350102},{"_id":"themes/book/source/css/_components/highlight/theme.scss","hash":"ec78a76370e44d9f1978c6f4ec2f3d523286f23a","modified":1720447350102},{"_id":"themes/book/source/favicon.png","hash":"2dbd6cb7b96c11aafd3d66ea99a35480c81da822","modified":1720598723199},{"_id":"public/数字取证/考试内容.html","hash":"b52b527368bd2da985bfc2755ae524659c3de9b9","modified":1720852896959},{"_id":"public/高级算法/GreedyAlgorithm.html","hash":"2dd0fde6e8ef3374ee09189828c6192290b1b0d7","modified":1720852896959},{"_id":"public/高级算法/PrimJarnik算法.html","hash":"3a78e38aac1b31e2027311153bc2493166c19d27","modified":1720852896959},{"_id":"public/高级算法/队栈.html","hash":"c25357170f30e703019396d007d7fd1c4eedcfb1","modified":1720852896959},{"_id":"public/高级算法/BFS.html","hash":"4c282052d78b512a68acbb0abcf8d33fd5cffe3b","modified":1720852896959},{"_id":"public/高级算法/P-NP问题.html","hash":"dff7be07087d0e500ca07f300b60be4707e2d3cf","modified":1720852896959},{"_id":"public/高级算法/高级算法目录.html","hash":"57f027f24ae6c8b4a2c9659e612f3144576727cf","modified":1720852896959},{"_id":"public/高级算法/Kruskal算法.html","hash":"26bada0b337d7a432bae80d3f22d119521ae76af","modified":1720852896959},{"_id":"public/高级算法/2019年题目.html","hash":"181d4cc4926a4123e066d363d696d2e9533d198c","modified":1720852896959},{"_id":"public/高级算法/图论.html","hash":"c6073a0187322a657db0859853b343bb31d670a3","modified":1720852896959},{"_id":"public/hello-world.html","hash":"907c094cc23aa0d1843340e316f5a58476ec39e8","modified":1720852896959},{"_id":"public/kk.html","hash":"62045bb4e643f20e936e3805363889a4cc775ce4","modified":1720852896959},{"_id":"public/archives/index.html","hash":"2f2b86ff0cd3eb51f1e304ac20347a8342f3a0a4","modified":1720852896959},{"_id":"public/archives/page/2/index.html","hash":"2f2b86ff0cd3eb51f1e304ac20347a8342f3a0a4","modified":1720852896959},{"_id":"public/archives/2024/index.html","hash":"2f2b86ff0cd3eb51f1e304ac20347a8342f3a0a4","modified":1720852896959},{"_id":"public/archives/2024/page/2/index.html","hash":"2f2b86ff0cd3eb51f1e304ac20347a8342f3a0a4","modified":1720852896959},{"_id":"public/archives/2024/07/index.html","hash":"2f2b86ff0cd3eb51f1e304ac20347a8342f3a0a4","modified":1720852896959},{"_id":"public/archives/2024/07/page/2/index.html","hash":"2f2b86ff0cd3eb51f1e304ac20347a8342f3a0a4","modified":1720852896959},{"_id":"public/index.html","hash":"9976e542e59a839626a6119f8bc6dbf8f72d9d3c","modified":1720852896959},{"_id":"public/page/2/index.html","hash":"d9c10a25ca19b5a723470d9004aa90800ce89aa7","modified":1720852896959},{"_id":"public/favicon.png","hash":"2dbd6cb7b96c11aafd3d66ea99a35480c81da822","modified":1720852896959},{"_id":"public/js/book.js","hash":"c150427c7397aea35ad83624f8db8f4b19846bb6","modified":1720852896959},{"_id":"public/js/book-menu.js","hash":"deebd62833f484c84e08357291ccc797c7544eb6","modified":1720852896959},{"_id":"public/js/book-post.js","hash":"d239e79163ceb5a37c9274c0c83010eea80554d8","modified":1720852896959},{"_id":"public/js/book-toc.js","hash":"fcbf2a88d9bab50dbd1337150a5909e8b9eecd13","modified":1720852896959},{"_id":"public/css/book.css","hash":"d64083b8f2807b534fac100e0a1191a4dd9bb890","modified":1720852896959}],"Category":[],"Data":[],"Page":[{"_content":"# 信息安全\n\n## H2\n\n- find nearest header\n- this unordered list will find H2\n\n### H3\n\n- [Markdown语法](/2024/07/08/hello-world/index.html)\n- [kk](/2024/07/08/kk/index.html)\n- this unordered list will find H3/2024/07/08/kk/index.html\n- - [kk](/2024/07/08/kk/index.html)\n\n# 软件开发\n\n#### 高级算法\n- [高级算法目录](/高级算法/高级算法目录.html)\n- [图论](/高级算法/图论.html)\n- [Kruskal算法](/高级算法/Kruskal算法.html)\n\n##### H5\n\n- find nearest header\n- this unordered list will find H5\n\n###### H6\n\n- find nearest header\n- this unordered list will find H6\n\n# 操作系统","source":"menu.md","raw":"# 信息安全\n\n## H2\n\n- find nearest header\n- this unordered list will find H2\n\n### H3\n\n- [Markdown语法](/2024/07/08/hello-world/index.html)\n- [kk](/2024/07/08/kk/index.html)\n- this unordered list will find H3/2024/07/08/kk/index.html\n- - [kk](/2024/07/08/kk/index.html)\n\n# 软件开发\n\n#### 高级算法\n- [高级算法目录](/高级算法/高级算法目录.html)\n- [图论](/高级算法/图论.html)\n- [Kruskal算法](/高级算法/Kruskal算法.html)\n\n##### H5\n\n- find nearest header\n- this unordered list will find H5\n\n###### H6\n\n- find nearest header\n- this unordered list will find H6\n\n# 操作系统","date":"2024-07-11T15:54:45.210Z","updated":"2024-07-10T10:10:55.221Z","path":"menu.html","title":"","comments":1,"layout":"page","_id":"clyjrdtl80001ha8a2x23919y","content":"<h1>信息安全</h1>\n<h2 id=\"H2\">H2</h2>\n<ul>\n<li>find nearest header</li>\n<li>this unordered list will find H2</li>\n</ul>\n<h3 id=\"H3\">H3</h3>\n<ul>\n<li><a href=\"/2024/07/08/hello-world/index.html\">Markdown语法</a></li>\n<li><a href=\"/2024/07/08/kk/index.html\">kk</a></li>\n<li>this unordered list will find H3/2024/07/08/kk/index.html</li>\n<li>\n<ul>\n<li><a href=\"/2024/07/08/kk/index.html\">kk</a></li>\n</ul>\n</li>\n</ul>\n<h1>软件开发</h1>\n<h4 id=\"高级算法\">高级算法</h4>\n<ul>\n<li><a href=\"/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E7%9B%AE%E5%BD%95.html\">高级算法目录</a></li>\n<li><a href=\"/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA.html\">图论</a></li>\n<li><a href=\"/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/Kruskal%E7%AE%97%E6%B3%95.html\">Kruskal算法</a></li>\n</ul>\n<h5 id=\"H5\">H5</h5>\n<ul>\n<li>find nearest header</li>\n<li>this unordered list will find H5</li>\n</ul>\n<h6 id=\"H6\">H6</h6>\n<ul>\n<li>find nearest header</li>\n<li>this unordered list will find H6</li>\n</ul>\n<h1>操作系统</h1>\n","excerpt":"","more":"<h1>信息安全</h1>\n<h2 id=\"H2\">H2</h2>\n<ul>\n<li>find nearest header</li>\n<li>this unordered list will find H2</li>\n</ul>\n<h3 id=\"H3\">H3</h3>\n<ul>\n<li><a href=\"/2024/07/08/hello-world/index.html\">Markdown语法</a></li>\n<li><a href=\"/2024/07/08/kk/index.html\">kk</a></li>\n<li>this unordered list will find H3/2024/07/08/kk/index.html</li>\n<li>\n<ul>\n<li><a href=\"/2024/07/08/kk/index.html\">kk</a></li>\n</ul>\n</li>\n</ul>\n<h1>软件开发</h1>\n<h4 id=\"高级算法\">高级算法</h4>\n<ul>\n<li><a href=\"/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E7%9B%AE%E5%BD%95.html\">高级算法目录</a></li>\n<li><a href=\"/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA.html\">图论</a></li>\n<li><a href=\"/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/Kruskal%E7%AE%97%E6%B3%95.html\">Kruskal算法</a></li>\n</ul>\n<h5 id=\"H5\">H5</h5>\n<ul>\n<li>find nearest header</li>\n<li>this unordered list will find H5</li>\n</ul>\n<h6 id=\"H6\">H6</h6>\n<ul>\n<li>find nearest header</li>\n<li>this unordered list will find H6</li>\n</ul>\n<h1>操作系统</h1>\n"},{"title":"Hello World","weight":10,"_content":"## 高级算法目录\n\n\n### 1.1. BFS (Breadth-First Search)\n\n广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。\n\n**实现步骤：**\n1. 创建一个空队列 `queue` 和一个空集合 `visited`。\n2. 将起始节点放入队列和访问集合中。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中的节点，将其标记为已访问。\n   - 将所有未访问过的邻居节点加入队列和访问集合。\n\n\n### 1.2. DFS (Depth-First Search)\n\n深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。\n\n**实现步骤：**\n1. 创建一个空集合 `visited` 来记录访问过的节点。\n2. 从起始节点开始调用递归函数 `dfs`：\n   - 将当前节点标记为已访问。\n   - 对于当前节点的每个未访问的邻居节点，递归调用 `dfs` 函数。\n\n## 2. Shortest Path Algorithms\n\n\n### 2.1. Dijkstra\n\nDijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。\n\n**实现步骤：**\n1. 创建一个优先队列 `pq` 和距离字典 `distances`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 将起始节点和距离 0 放入队列。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中距离最小的节点。\n   - 对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。\n\n---\n\n### 2.2. Bellman-Ford\n\nBellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。\n\n**实现步骤：**\n1. 创建距离字典 `distance`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 进行 |V|-1 次迭代，每次迭代遍历所有边：\n   - 对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。\n3. 再次遍历所有边，检查是否存在负权环。\n\n## 3. Pattern Matching Algorithms\n\n\n### 3.1. KMP (Knuth-Morris-Pratt)\n\nKMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。\n\n**实现步骤：**\n1. 构建部分匹配表 `lps`，用于指示在匹配失败时模式串应移动的位置。\n2. 使用两个指针 i 和 j 分别遍历文本和模式串：\n   - 如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。\n   - 如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。\n   - 如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。\n\n\n\n### 3.2. Boyer-Moore\n\nBoyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。\n\n**实现步骤：**\n1. 构建字符到最后出现位置的映射表 `last`。\n2. 使用两个指针 s 和 j 分别遍历文本和模式串：\n   - 从右向左比较模式串和文本，当匹配失败时根据 `last` 表跳过一定的字符。\n   - 如果完全匹配，记录匹配的起始位置并移动 s。\n   - 如果部分匹配但未完全匹配，根据 `last` 表调整 j 的位置。\n\n这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。\n","source":"home.md","raw":"---\ntitle: Hello World\nweight: 10\n---\n## 高级算法目录\n\n\n### 1.1. BFS (Breadth-First Search)\n\n广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。\n\n**实现步骤：**\n1. 创建一个空队列 `queue` 和一个空集合 `visited`。\n2. 将起始节点放入队列和访问集合中。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中的节点，将其标记为已访问。\n   - 将所有未访问过的邻居节点加入队列和访问集合。\n\n\n### 1.2. DFS (Depth-First Search)\n\n深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。\n\n**实现步骤：**\n1. 创建一个空集合 `visited` 来记录访问过的节点。\n2. 从起始节点开始调用递归函数 `dfs`：\n   - 将当前节点标记为已访问。\n   - 对于当前节点的每个未访问的邻居节点，递归调用 `dfs` 函数。\n\n## 2. Shortest Path Algorithms\n\n\n### 2.1. Dijkstra\n\nDijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。\n\n**实现步骤：**\n1. 创建一个优先队列 `pq` 和距离字典 `distances`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 将起始节点和距离 0 放入队列。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中距离最小的节点。\n   - 对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。\n\n---\n\n### 2.2. Bellman-Ford\n\nBellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。\n\n**实现步骤：**\n1. 创建距离字典 `distance`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 进行 |V|-1 次迭代，每次迭代遍历所有边：\n   - 对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。\n3. 再次遍历所有边，检查是否存在负权环。\n\n## 3. Pattern Matching Algorithms\n\n\n### 3.1. KMP (Knuth-Morris-Pratt)\n\nKMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。\n\n**实现步骤：**\n1. 构建部分匹配表 `lps`，用于指示在匹配失败时模式串应移动的位置。\n2. 使用两个指针 i 和 j 分别遍历文本和模式串：\n   - 如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。\n   - 如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。\n   - 如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。\n\n\n\n### 3.2. Boyer-Moore\n\nBoyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。\n\n**实现步骤：**\n1. 构建字符到最后出现位置的映射表 `last`。\n2. 使用两个指针 s 和 j 分别遍历文本和模式串：\n   - 从右向左比较模式串和文本，当匹配失败时根据 `last` 表跳过一定的字符。\n   - 如果完全匹配，记录匹配的起始位置并移动 s。\n   - 如果部分匹配但未完全匹配，根据 `last` 表调整 j 的位置。\n\n这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。\n","date":"2024-07-10T07:57:56.385Z","updated":"2024-07-08T15:50:16.682Z","path":"home.html","comments":1,"layout":"page","_id":"clyjrdtlb0003ha8a0o1b9arl","content":"<h2 id=\"高级算法目录\">高级算法目录</h2>\n<h3 id=\"1-1-BFS-Breadth-First-Search\">1.1. BFS (Breadth-First Search)</h3>\n<p>广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空队列 <code>queue</code> 和一个空集合 <code>visited</code>。</li>\n<li>将起始节点放入队列和访问集合中。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中的节点，将其标记为已访问。</li>\n<li>将所有未访问过的邻居节点加入队列和访问集合。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-2-DFS-Depth-First-Search\">1.2. DFS (Depth-First Search)</h3>\n<p>深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空集合 <code>visited</code> 来记录访问过的节点。</li>\n<li>从起始节点开始调用递归函数 <code>dfs</code>：\n<ul>\n<li>将当前节点标记为已访问。</li>\n<li>对于当前节点的每个未访问的邻居节点，递归调用 <code>dfs</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-Shortest-Path-Algorithms\">2. Shortest Path Algorithms</h2>\n<h3 id=\"2-1-Dijkstra\">2.1. Dijkstra</h3>\n<p>Dijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个优先队列 <code>pq</code> 和距离字典 <code>distances</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>将起始节点和距离 0 放入队列。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中距离最小的节点。</li>\n<li>对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-2-Bellman-Ford\">2.2. Bellman-Ford</h3>\n<p>Bellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建距离字典 <code>distance</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>进行 |V|-1 次迭代，每次迭代遍历所有边：\n<ul>\n<li>对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。</li>\n</ul>\n</li>\n<li>再次遍历所有边，检查是否存在负权环。</li>\n</ol>\n<h2 id=\"3-Pattern-Matching-Algorithms\">3. Pattern Matching Algorithms</h2>\n<h3 id=\"3-1-KMP-Knuth-Morris-Pratt\">3.1. KMP (Knuth-Morris-Pratt)</h3>\n<p>KMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建部分匹配表 <code>lps</code>，用于指示在匹配失败时模式串应移动的位置。</li>\n<li>使用两个指针 i 和 j 分别遍历文本和模式串：\n<ul>\n<li>如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。</li>\n<li>如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。</li>\n<li>如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-Boyer-Moore\">3.2. Boyer-Moore</h3>\n<p>Boyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建字符到最后出现位置的映射表 <code>last</code>。</li>\n<li>使用两个指针 s 和 j 分别遍历文本和模式串：\n<ul>\n<li>从右向左比较模式串和文本，当匹配失败时根据 <code>last</code> 表跳过一定的字符。</li>\n<li>如果完全匹配，记录匹配的起始位置并移动 s。</li>\n<li>如果部分匹配但未完全匹配，根据 <code>last</code> 表调整 j 的位置。</li>\n</ul>\n</li>\n</ol>\n<p>这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。</p>\n","excerpt":"","more":"<h2 id=\"高级算法目录\">高级算法目录</h2>\n<h3 id=\"1-1-BFS-Breadth-First-Search\">1.1. BFS (Breadth-First Search)</h3>\n<p>广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空队列 <code>queue</code> 和一个空集合 <code>visited</code>。</li>\n<li>将起始节点放入队列和访问集合中。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中的节点，将其标记为已访问。</li>\n<li>将所有未访问过的邻居节点加入队列和访问集合。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-2-DFS-Depth-First-Search\">1.2. DFS (Depth-First Search)</h3>\n<p>深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空集合 <code>visited</code> 来记录访问过的节点。</li>\n<li>从起始节点开始调用递归函数 <code>dfs</code>：\n<ul>\n<li>将当前节点标记为已访问。</li>\n<li>对于当前节点的每个未访问的邻居节点，递归调用 <code>dfs</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-Shortest-Path-Algorithms\">2. Shortest Path Algorithms</h2>\n<h3 id=\"2-1-Dijkstra\">2.1. Dijkstra</h3>\n<p>Dijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个优先队列 <code>pq</code> 和距离字典 <code>distances</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>将起始节点和距离 0 放入队列。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中距离最小的节点。</li>\n<li>对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-2-Bellman-Ford\">2.2. Bellman-Ford</h3>\n<p>Bellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建距离字典 <code>distance</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>进行 |V|-1 次迭代，每次迭代遍历所有边：\n<ul>\n<li>对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。</li>\n</ul>\n</li>\n<li>再次遍历所有边，检查是否存在负权环。</li>\n</ol>\n<h2 id=\"3-Pattern-Matching-Algorithms\">3. Pattern Matching Algorithms</h2>\n<h3 id=\"3-1-KMP-Knuth-Morris-Pratt\">3.1. KMP (Knuth-Morris-Pratt)</h3>\n<p>KMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建部分匹配表 <code>lps</code>，用于指示在匹配失败时模式串应移动的位置。</li>\n<li>使用两个指针 i 和 j 分别遍历文本和模式串：\n<ul>\n<li>如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。</li>\n<li>如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。</li>\n<li>如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-Boyer-Moore\">3.2. Boyer-Moore</h3>\n<p>Boyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建字符到最后出现位置的映射表 <code>last</code>。</li>\n<li>使用两个指针 s 和 j 分别遍历文本和模式串：\n<ul>\n<li>从右向左比较模式串和文本，当匹配失败时根据 <code>last</code> 表跳过一定的字符。</li>\n<li>如果完全匹配，记录匹配的起始位置并移动 s。</li>\n<li>如果部分匹配但未完全匹配，根据 <code>last</code> 表调整 j 的位置。</li>\n</ul>\n</li>\n</ol>\n<p>这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。</p>\n"}],"Post":[{"_content":"","source":"_posts/高级算法/Kruskal算法.md","raw":"","slug":"高级算法/Kruskal算法","published":1,"date":"2024-07-10T09:46:17.464Z","updated":"2024-07-10T09:46:17.464Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clyjrdtkv0000ha8aha37d3m5","content":"","excerpt":"","more":""},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-07-08T13:59:15.442Z","updated":"2024-07-08T13:59:15.442Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtl90002ha8a4ttb00p8","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post\">Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\">Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\">Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\">Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"kk","weight":10,"_content":"## 高级算法目录\n\n\n### 1.1. BFS (Breadth-First Search)\n\n广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。\n\n**实现步骤：**\n1. 创建一个空队列 `queue` 和一个空集合 `visited`。\n2. 将起始节点放入队列和访问集合中。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中的节点，将其标记为已访问。\n   - 将所有未访问过的邻居节点加入队列和访问集合。\n\n\n### 1.2. DFS (Depth-First Search)\n\n深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。\n\n**实现步骤：**\n1. 创建一个空集合 `visited` 来记录访问过的节点。\n2. 从起始节点开始调用递归函数 `dfs`：\n   - 将当前节点标记为已访问。\n   - 对于当前节点的每个未访问的邻居节点，递归调用 `dfs` 函数。\n\n## 2. Shortest Path Algorithms\n\n\n### 2.1. Dijkstra\n\nDijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。\n\n**实现步骤：**\n1. 创建一个优先队列 `pq` 和距离字典 `distances`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 将起始节点和距离 0 放入队列。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中距离最小的节点。\n   - 对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。\n\n---\n\n### 2.2. Bellman-Ford\n\nBellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。\n\n**实现步骤：**\n1. 创建距离字典 `distance`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 进行 |V|-1 次迭代，每次迭代遍历所有边：\n   - 对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。\n3. 再次遍历所有边，检查是否存在负权环。\n\n## 3. Pattern Matching Algorithms\n\n\n### 3.1. KMP (Knuth-Morris-Pratt)\n\nKMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。\n\n**实现步骤：**\n1. 构建部分匹配表 `lps`，用于指示在匹配失败时模式串应移动的位置。\n2. 使用两个指针 i 和 j 分别遍历文本和模式串：\n   - 如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。\n   - 如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。\n   - 如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。\n\n\n\n### 3.2. Boyer-Moore\n\nBoyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。\n\n**实现步骤：**\n1. 构建字符到最后出现位置的映射表 `last`。\n2. 使用两个指针 s 和 j 分别遍历文本和模式串：\n   - 从右向左比较模式串和文本，当匹配失败时根据 `last` 表跳过一定的字符。\n   - 如果完全匹配，记录匹配的起始位置并移动 s。\n   - 如果部分匹配但未完全匹配，根据 `last` 表调整 j 的位置。\n\n这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。\n","source":"_posts/kk.md","raw":"---\ntitle: kk\nweight: 10\n---\n## 高级算法目录\n\n\n### 1.1. BFS (Breadth-First Search)\n\n广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。\n\n**实现步骤：**\n1. 创建一个空队列 `queue` 和一个空集合 `visited`。\n2. 将起始节点放入队列和访问集合中。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中的节点，将其标记为已访问。\n   - 将所有未访问过的邻居节点加入队列和访问集合。\n\n\n### 1.2. DFS (Depth-First Search)\n\n深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。\n\n**实现步骤：**\n1. 创建一个空集合 `visited` 来记录访问过的节点。\n2. 从起始节点开始调用递归函数 `dfs`：\n   - 将当前节点标记为已访问。\n   - 对于当前节点的每个未访问的邻居节点，递归调用 `dfs` 函数。\n\n## 2. Shortest Path Algorithms\n\n\n### 2.1. Dijkstra\n\nDijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。\n\n**实现步骤：**\n1. 创建一个优先队列 `pq` 和距离字典 `distances`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 将起始节点和距离 0 放入队列。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中距离最小的节点。\n   - 对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。\n\n---\n\n### 2.2. Bellman-Ford\n\nBellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。\n\n**实现步骤：**\n1. 创建距离字典 `distance`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 进行 |V|-1 次迭代，每次迭代遍历所有边：\n   - 对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。\n3. 再次遍历所有边，检查是否存在负权环。\n\n## 3. Pattern Matching Algorithms\n\n\n### 3.1. KMP (Knuth-Morris-Pratt)\n\nKMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。\n\n**实现步骤：**\n1. 构建部分匹配表 `lps`，用于指示在匹配失败时模式串应移动的位置。\n2. 使用两个指针 i 和 j 分别遍历文本和模式串：\n   - 如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。\n   - 如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。\n   - 如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。\n\n\n\n### 3.2. Boyer-Moore\n\nBoyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。\n\n**实现步骤：**\n1. 构建字符到最后出现位置的映射表 `last`。\n2. 使用两个指针 s 和 j 分别遍历文本和模式串：\n   - 从右向左比较模式串和文本，当匹配失败时根据 `last` 表跳过一定的字符。\n   - 如果完全匹配，记录匹配的起始位置并移动 s。\n   - 如果部分匹配但未完全匹配，根据 `last` 表调整 j 的位置。\n\n这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。\n","slug":"kk","published":1,"date":"2024-07-08T13:59:15.442Z","updated":"2024-07-09T09:30:30.652Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlb0004ha8acsqc8og8","content":"<h2 id=\"高级算法目录\">高级算法目录</h2>\n<h3 id=\"1-1-BFS-Breadth-First-Search\">1.1. BFS (Breadth-First Search)</h3>\n<p>广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空队列 <code>queue</code> 和一个空集合 <code>visited</code>。</li>\n<li>将起始节点放入队列和访问集合中。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中的节点，将其标记为已访问。</li>\n<li>将所有未访问过的邻居节点加入队列和访问集合。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-2-DFS-Depth-First-Search\">1.2. DFS (Depth-First Search)</h3>\n<p>深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空集合 <code>visited</code> 来记录访问过的节点。</li>\n<li>从起始节点开始调用递归函数 <code>dfs</code>：\n<ul>\n<li>将当前节点标记为已访问。</li>\n<li>对于当前节点的每个未访问的邻居节点，递归调用 <code>dfs</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-Shortest-Path-Algorithms\">2. Shortest Path Algorithms</h2>\n<h3 id=\"2-1-Dijkstra\">2.1. Dijkstra</h3>\n<p>Dijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个优先队列 <code>pq</code> 和距离字典 <code>distances</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>将起始节点和距离 0 放入队列。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中距离最小的节点。</li>\n<li>对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-2-Bellman-Ford\">2.2. Bellman-Ford</h3>\n<p>Bellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建距离字典 <code>distance</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>进行 |V|-1 次迭代，每次迭代遍历所有边：\n<ul>\n<li>对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。</li>\n</ul>\n</li>\n<li>再次遍历所有边，检查是否存在负权环。</li>\n</ol>\n<h2 id=\"3-Pattern-Matching-Algorithms\">3. Pattern Matching Algorithms</h2>\n<h3 id=\"3-1-KMP-Knuth-Morris-Pratt\">3.1. KMP (Knuth-Morris-Pratt)</h3>\n<p>KMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建部分匹配表 <code>lps</code>，用于指示在匹配失败时模式串应移动的位置。</li>\n<li>使用两个指针 i 和 j 分别遍历文本和模式串：\n<ul>\n<li>如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。</li>\n<li>如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。</li>\n<li>如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-Boyer-Moore\">3.2. Boyer-Moore</h3>\n<p>Boyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建字符到最后出现位置的映射表 <code>last</code>。</li>\n<li>使用两个指针 s 和 j 分别遍历文本和模式串：\n<ul>\n<li>从右向左比较模式串和文本，当匹配失败时根据 <code>last</code> 表跳过一定的字符。</li>\n<li>如果完全匹配，记录匹配的起始位置并移动 s。</li>\n<li>如果部分匹配但未完全匹配，根据 <code>last</code> 表调整 j 的位置。</li>\n</ul>\n</li>\n</ol>\n<p>这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。</p>\n","excerpt":"","more":"<h2 id=\"高级算法目录\">高级算法目录</h2>\n<h3 id=\"1-1-BFS-Breadth-First-Search\">1.1. BFS (Breadth-First Search)</h3>\n<p>广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空队列 <code>queue</code> 和一个空集合 <code>visited</code>。</li>\n<li>将起始节点放入队列和访问集合中。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中的节点，将其标记为已访问。</li>\n<li>将所有未访问过的邻居节点加入队列和访问集合。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-2-DFS-Depth-First-Search\">1.2. DFS (Depth-First Search)</h3>\n<p>深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空集合 <code>visited</code> 来记录访问过的节点。</li>\n<li>从起始节点开始调用递归函数 <code>dfs</code>：\n<ul>\n<li>将当前节点标记为已访问。</li>\n<li>对于当前节点的每个未访问的邻居节点，递归调用 <code>dfs</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-Shortest-Path-Algorithms\">2. Shortest Path Algorithms</h2>\n<h3 id=\"2-1-Dijkstra\">2.1. Dijkstra</h3>\n<p>Dijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个优先队列 <code>pq</code> 和距离字典 <code>distances</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>将起始节点和距离 0 放入队列。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中距离最小的节点。</li>\n<li>对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-2-Bellman-Ford\">2.2. Bellman-Ford</h3>\n<p>Bellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建距离字典 <code>distance</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>进行 |V|-1 次迭代，每次迭代遍历所有边：\n<ul>\n<li>对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。</li>\n</ul>\n</li>\n<li>再次遍历所有边，检查是否存在负权环。</li>\n</ol>\n<h2 id=\"3-Pattern-Matching-Algorithms\">3. Pattern Matching Algorithms</h2>\n<h3 id=\"3-1-KMP-Knuth-Morris-Pratt\">3.1. KMP (Knuth-Morris-Pratt)</h3>\n<p>KMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建部分匹配表 <code>lps</code>，用于指示在匹配失败时模式串应移动的位置。</li>\n<li>使用两个指针 i 和 j 分别遍历文本和模式串：\n<ul>\n<li>如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。</li>\n<li>如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。</li>\n<li>如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-Boyer-Moore\">3.2. Boyer-Moore</h3>\n<p>Boyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建字符到最后出现位置的映射表 <code>last</code>。</li>\n<li>使用两个指针 s 和 j 分别遍历文本和模式串：\n<ul>\n<li>从右向左比较模式串和文本，当匹配失败时根据 <code>last</code> 表跳过一定的字符。</li>\n<li>如果完全匹配，记录匹配的起始位置并移动 s。</li>\n<li>如果部分匹配但未完全匹配，根据 <code>last</code> 表调整 j 的位置。</li>\n</ul>\n</li>\n</ol>\n<p>这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。</p>\n"},{"title":"数字取证","_content":"## 1. Final Exam\n`考加粗部分`\n\n- **了解数字取证和调查的原理和先进技术。**\n\n- 组织计算机取证、移动取证、网络取证和大数据取证方面的数字调查。\n\n- **评估符合专业标准和调查流程的数字调查：识别、保存、检查和分析。**\n\n- 报告违反法律、伦理、道德、政策和/或社会标准的计算机数据潜在安全漏洞。","source":"_posts/数字取证/考试内容.md","raw":"\n---\ntitle: 数字取证\n---\n## 1. Final Exam\n`考加粗部分`\n\n- **了解数字取证和调查的原理和先进技术。**\n\n- 组织计算机取证、移动取证、网络取证和大数据取证方面的数字调查。\n\n- **评估符合专业标准和调查流程的数字调查：识别、保存、检查和分析。**\n\n- 报告违反法律、伦理、道德、政策和/或社会标准的计算机数据潜在安全漏洞。","slug":"数字取证/考试内容","published":1,"date":"2024-07-13T06:36:50.749Z","updated":"2024-07-13T06:40:00.759Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtld0005ha8ah4bnelq0","content":"<h2 id=\"1-Final-Exam\">1. Final Exam</h2>\n<p><code>考加粗部分</code></p>\n<ul>\n<li>\n<p><strong>了解数字取证和调查的原理和先进技术。</strong></p>\n</li>\n<li>\n<p>组织计算机取证、移动取证、网络取证和大数据取证方面的数字调查。</p>\n</li>\n<li>\n<p><strong>评估符合专业标准和调查流程的数字调查：识别、保存、检查和分析。</strong></p>\n</li>\n<li>\n<p>报告违反法律、伦理、道德、政策和/或社会标准的计算机数据潜在安全漏洞。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"1-Final-Exam\">1. Final Exam</h2>\n<p><code>考加粗部分</code></p>\n<ul>\n<li>\n<p><strong>了解数字取证和调查的原理和先进技术。</strong></p>\n</li>\n<li>\n<p>组织计算机取证、移动取证、网络取证和大数据取证方面的数字调查。</p>\n</li>\n<li>\n<p><strong>评估符合专业标准和调查流程的数字调查：识别、保存、检查和分析。</strong></p>\n</li>\n<li>\n<p>报告违反法律、伦理、道德、政策和/或社会标准的计算机数据潜在安全漏洞。</p>\n</li>\n</ul>\n"},{"title":"2019年题目","_content":"**EN:**\n\n(a) Write a straightforward recursive function to calculate Fibonacci number.\n\n(b) What is the time complexity of the function in (1)(a) above, in big O? Explain your answer.\n\n(c) What is dynamic programming? Apply dynamic programming approach to calculate a Fibonacci number, and describe the way dynamic programming calculates the Fibonacci number using an appropriate example.\n\n**ZH:**\n\n（a）写一个直接的递归函数来计算斐波那契数。\n\n（b）上面（1）（a）中的函数的时间复杂度是什么，大 O 是多少？解释你的答案。\n\n（c）什么是动态规划？应用动态规划方法来计算斐波那契数，并描述动态规划使用适当的示例计算斐波那契数的方法。\n\n**中文解释：**\n\n**（a）斐波那契数的递归函数**\n\n斐波那契数列是一个数列，其中前两个数为 0 和 1，而从第三个数开始，每个数都是前两个数的和。一个简单的递归函数可以用于计算斐波那契数：\n\n```python\n\ndef fibonacci(n):\n\nif n < 2:\n\nreturn n\n\nelse:\n\nreturn fibonacci(n-1) + fibonacci(n-2)\n\n```\n\n**（b）时间复杂度**\n\n给定自然数 n，递归函数 fibonacci(n) 的时间复杂度为 O(2^n)。这是因为对于每个输入 n，该函数都会递归地调用自身两次，并且这种模式会一直重复到 n 达到 0 或 1。\n\n**（c）动态规划**\n\n动态规划是一种解决优化问题的技术，它将问题分解成子问题，然后通过存储子问题的解决方案来避免重复计算。对于斐波那契数，我们可以使用动态规划来计算斐波那契数，方法是存储已计算出的斐波那契数。\n\n以下是动态规划方法计算斐波那契数的一个示例：\n\n```python\n\ndef fibonacci_dp(n):\n\nfib_cache = [0, 1]  # 存储已计算出的斐波那契数\n\nwhile n >= len(fib_cache):\n\nnext_fib = fib_cache[-1] + fib_cache[-2]\n\nfib_cache.append(next_fib)\n\nreturn fib_cache[n]\n\n```\n\n在该实现中，fib_cache 列表存储已计算出的斐波那契数。当 n 大于 fib_cache 的长度时，它将计算并存储下一个斐波那契数。通过使用 fib_cache，动态规划方法避免了重复计算，从而将时间复杂度从 O(2^n) 降低到 O(n)。","source":"_posts/高级算法/2019年题目.md","raw":"---\ntitle: 2019年题目\n---\n**EN:**\n\n(a) Write a straightforward recursive function to calculate Fibonacci number.\n\n(b) What is the time complexity of the function in (1)(a) above, in big O? Explain your answer.\n\n(c) What is dynamic programming? Apply dynamic programming approach to calculate a Fibonacci number, and describe the way dynamic programming calculates the Fibonacci number using an appropriate example.\n\n**ZH:**\n\n（a）写一个直接的递归函数来计算斐波那契数。\n\n（b）上面（1）（a）中的函数的时间复杂度是什么，大 O 是多少？解释你的答案。\n\n（c）什么是动态规划？应用动态规划方法来计算斐波那契数，并描述动态规划使用适当的示例计算斐波那契数的方法。\n\n**中文解释：**\n\n**（a）斐波那契数的递归函数**\n\n斐波那契数列是一个数列，其中前两个数为 0 和 1，而从第三个数开始，每个数都是前两个数的和。一个简单的递归函数可以用于计算斐波那契数：\n\n```python\n\ndef fibonacci(n):\n\nif n < 2:\n\nreturn n\n\nelse:\n\nreturn fibonacci(n-1) + fibonacci(n-2)\n\n```\n\n**（b）时间复杂度**\n\n给定自然数 n，递归函数 fibonacci(n) 的时间复杂度为 O(2^n)。这是因为对于每个输入 n，该函数都会递归地调用自身两次，并且这种模式会一直重复到 n 达到 0 或 1。\n\n**（c）动态规划**\n\n动态规划是一种解决优化问题的技术，它将问题分解成子问题，然后通过存储子问题的解决方案来避免重复计算。对于斐波那契数，我们可以使用动态规划来计算斐波那契数，方法是存储已计算出的斐波那契数。\n\n以下是动态规划方法计算斐波那契数的一个示例：\n\n```python\n\ndef fibonacci_dp(n):\n\nfib_cache = [0, 1]  # 存储已计算出的斐波那契数\n\nwhile n >= len(fib_cache):\n\nnext_fib = fib_cache[-1] + fib_cache[-2]\n\nfib_cache.append(next_fib)\n\nreturn fib_cache[n]\n\n```\n\n在该实现中，fib_cache 列表存储已计算出的斐波那契数。当 n 大于 fib_cache 的长度时，它将计算并存储下一个斐波那契数。通过使用 fib_cache，动态规划方法避免了重复计算，从而将时间复杂度从 O(2^n) 降低到 O(n)。","slug":"高级算法/2019年题目","published":1,"date":"2024-07-10T08:14:31.325Z","updated":"2024-07-10T10:15:35.708Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtle0006ha8a0zbpg9w4","content":"<p><strong>EN:</strong></p>\n<p>(a) Write a straightforward recursive function to calculate Fibonacci number.</p>\n<p>(b) What is the time complexity of the function in (1)(a) above, in big O? Explain your answer.</p>\n<p>© What is dynamic programming? Apply dynamic programming approach to calculate a Fibonacci number, and describe the way dynamic programming calculates the Fibonacci number using an appropriate example.</p>\n<p><strong>ZH:</strong></p>\n<p>（a）写一个直接的递归函数来计算斐波那契数。</p>\n<p>（b）上面（1）（a）中的函数的时间复杂度是什么，大 O 是多少？解释你的答案。</p>\n<p>（c）什么是动态规划？应用动态规划方法来计算斐波那契数，并描述动态规划使用适当的示例计算斐波那契数的方法。</p>\n<p><strong>中文解释：</strong></p>\n<p><strong>（a）斐波那契数的递归函数</strong></p>\n<p>斐波那契数列是一个数列，其中前两个数为 0 和 1，而从第三个数开始，每个数都是前两个数的和。一个简单的递归函数可以用于计算斐波那契数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>（b）时间复杂度</strong></p>\n<p>给定自然数 n，递归函数 fibonacci(n) 的时间复杂度为 O(2^n)。这是因为对于每个输入 n，该函数都会递归地调用自身两次，并且这种模式会一直重复到 n 达到 0 或 1。</p>\n<p><strong>（c）动态规划</strong></p>\n<p>动态规划是一种解决优化问题的技术，它将问题分解成子问题，然后通过存储子问题的解决方案来避免重复计算。对于斐波那契数，我们可以使用动态规划来计算斐波那契数，方法是存储已计算出的斐波那契数。</p>\n<p>以下是动态规划方法计算斐波那契数的一个示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fibonacci_dp</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">fib_cache = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]  <span class=\"comment\"># 存储已计算出的斐波那契数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &gt;= <span class=\"built_in\">len</span>(fib_cache):</span><br><span class=\"line\"></span><br><span class=\"line\">next_fib = fib_cache[-<span class=\"number\">1</span>] + fib_cache[-<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">fib_cache.append(next_fib)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> fib_cache[n]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在该实现中，fib_cache 列表存储已计算出的斐波那契数。当 n 大于 fib_cache 的长度时，它将计算并存储下一个斐波那契数。通过使用 fib_cache，动态规划方法避免了重复计算，从而将时间复杂度从 O(2^n) 降低到 O(n)。</p>\n","excerpt":"","more":"<p><strong>EN:</strong></p>\n<p>(a) Write a straightforward recursive function to calculate Fibonacci number.</p>\n<p>(b) What is the time complexity of the function in (1)(a) above, in big O? Explain your answer.</p>\n<p>© What is dynamic programming? Apply dynamic programming approach to calculate a Fibonacci number, and describe the way dynamic programming calculates the Fibonacci number using an appropriate example.</p>\n<p><strong>ZH:</strong></p>\n<p>（a）写一个直接的递归函数来计算斐波那契数。</p>\n<p>（b）上面（1）（a）中的函数的时间复杂度是什么，大 O 是多少？解释你的答案。</p>\n<p>（c）什么是动态规划？应用动态规划方法来计算斐波那契数，并描述动态规划使用适当的示例计算斐波那契数的方法。</p>\n<p><strong>中文解释：</strong></p>\n<p><strong>（a）斐波那契数的递归函数</strong></p>\n<p>斐波那契数列是一个数列，其中前两个数为 0 和 1，而从第三个数开始，每个数都是前两个数的和。一个简单的递归函数可以用于计算斐波那契数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> n &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> fibonacci(n-<span class=\"number\">1</span>) + fibonacci(n-<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>（b）时间复杂度</strong></p>\n<p>给定自然数 n，递归函数 fibonacci(n) 的时间复杂度为 O(2^n)。这是因为对于每个输入 n，该函数都会递归地调用自身两次，并且这种模式会一直重复到 n 达到 0 或 1。</p>\n<p><strong>（c）动态规划</strong></p>\n<p>动态规划是一种解决优化问题的技术，它将问题分解成子问题，然后通过存储子问题的解决方案来避免重复计算。对于斐波那契数，我们可以使用动态规划来计算斐波那契数，方法是存储已计算出的斐波那契数。</p>\n<p>以下是动态规划方法计算斐波那契数的一个示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fibonacci_dp</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">fib_cache = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]  <span class=\"comment\"># 存储已计算出的斐波那契数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &gt;= <span class=\"built_in\">len</span>(fib_cache):</span><br><span class=\"line\"></span><br><span class=\"line\">next_fib = fib_cache[-<span class=\"number\">1</span>] + fib_cache[-<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">fib_cache.append(next_fib)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> fib_cache[n]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在该实现中，fib_cache 列表存储已计算出的斐波那契数。当 n 大于 fib_cache 的长度时，它将计算并存储下一个斐波那契数。通过使用 fib_cache，动态规划方法避免了重复计算，从而将时间复杂度从 O(2^n) 降低到 O(n)。</p>\n"},{"title":"BFS (Breadth-First Search)","weight":20,"_content":"# BFS (Breadth-First Search)\n\n\n## 1. 用途\n\n广度优先搜索（BFS）在现实中有许多实际用途，主要用于解决以下问题：\n1. 最短路径搜索：BFS 可以用于无权图或者所有边权重相同的图中寻找最短路径。这在网络路由、社交网络中的最短友谊链、广告投放中的最短路径传播等方面有广泛应用。\n1. 图的连通性检测：BFS 可以用来检测图是否是连通的，即从一个节点能否到达图中的所有其他节点。这在计算机网络中的连通性检测、社交网络中的社群发现等方面很有用。\n1. 状态空间搜索：BFS 可以应用于状态空间搜索问题，如在迷宫游戏中找到从起点到终点的最短路径，或者在解决八皇后问题等排列组合问题时寻找最优解。\n1. Web爬虫：在网络爬虫中，BFS 用来抓取网页，并且可以限制爬取深度，确保优先爬取距离种子页面更近的链接。\n1. 层次遍历：BFS 的特性使其适合进行层次遍历，例如`树的层次遍历`、多级菜单的展开等。\n1. 游戏开发：在游戏开发中，BFS 可以用于寻找玩家或NPC的移动路径，或者在地图中寻找最近的敌人或资源。\n\n\n\n## 2. 代码\n\n```java\nimport java.util.*;\n\npublic class BFSGraphTraversal {\n    // 使用邻接列表表示图\n    private Map<Character, List<Character>> graph;\n\n    public BFSGraphTraversal() {\n        graph = new HashMap<>();\n    }\n\n    // 添加边的方法\n    public void addEdge(char from, char to) {\n        graph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\n        graph.computeIfAbsent(to, k -> new ArrayList<>()).add(from); // 如果是有向图，删除此行\n    }\n\n    // BFS 遍历方法\n    public List<Character> bfs(char start) {\n        List<Character> traversalOrder = new ArrayList<>();\n        if (!graph.containsKey(start)) {\n            return traversalOrder;\n        }\n\n        Queue<Character> queue = new LinkedList<>();\n        Set<Character> visited = new HashSet<>();\n\n        queue.offer(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            char current = queue.poll();\n            traversalOrder.add(current);\n\n            for (char neighbor : graph.getOrDefault(current, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(neighbor);\n                    visited.add(neighbor);\n                }\n            }\n        }\n\n        return traversalOrder;\n    }\n\n    public static void main(String[] args) {\n        BFSGraphTraversal graph = new BFSGraphTraversal();\n\n        // 添加图的边\n        graph.addEdge('A', 'B');\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'D');\n        graph.addEdge('B', 'E');\n        graph.addEdge('C', 'F');\n        graph.addEdge('E', 'F');\n\n        // 从节点 'A' 开始进行 BFS 遍历\n        List<Character> traversalOrder = graph.bfs('A');\n        System.out.println(\"BFS traversal order starting from node A: \" + traversalOrder);\n    }\n}\n\n\n```","source":"_posts/高级算法/BFS.md","raw":"---\ntitle: BFS (Breadth-First Search)\nweight: 20\n---\n# BFS (Breadth-First Search)\n\n\n## 1. 用途\n\n广度优先搜索（BFS）在现实中有许多实际用途，主要用于解决以下问题：\n1. 最短路径搜索：BFS 可以用于无权图或者所有边权重相同的图中寻找最短路径。这在网络路由、社交网络中的最短友谊链、广告投放中的最短路径传播等方面有广泛应用。\n1. 图的连通性检测：BFS 可以用来检测图是否是连通的，即从一个节点能否到达图中的所有其他节点。这在计算机网络中的连通性检测、社交网络中的社群发现等方面很有用。\n1. 状态空间搜索：BFS 可以应用于状态空间搜索问题，如在迷宫游戏中找到从起点到终点的最短路径，或者在解决八皇后问题等排列组合问题时寻找最优解。\n1. Web爬虫：在网络爬虫中，BFS 用来抓取网页，并且可以限制爬取深度，确保优先爬取距离种子页面更近的链接。\n1. 层次遍历：BFS 的特性使其适合进行层次遍历，例如`树的层次遍历`、多级菜单的展开等。\n1. 游戏开发：在游戏开发中，BFS 可以用于寻找玩家或NPC的移动路径，或者在地图中寻找最近的敌人或资源。\n\n\n\n## 2. 代码\n\n```java\nimport java.util.*;\n\npublic class BFSGraphTraversal {\n    // 使用邻接列表表示图\n    private Map<Character, List<Character>> graph;\n\n    public BFSGraphTraversal() {\n        graph = new HashMap<>();\n    }\n\n    // 添加边的方法\n    public void addEdge(char from, char to) {\n        graph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\n        graph.computeIfAbsent(to, k -> new ArrayList<>()).add(from); // 如果是有向图，删除此行\n    }\n\n    // BFS 遍历方法\n    public List<Character> bfs(char start) {\n        List<Character> traversalOrder = new ArrayList<>();\n        if (!graph.containsKey(start)) {\n            return traversalOrder;\n        }\n\n        Queue<Character> queue = new LinkedList<>();\n        Set<Character> visited = new HashSet<>();\n\n        queue.offer(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            char current = queue.poll();\n            traversalOrder.add(current);\n\n            for (char neighbor : graph.getOrDefault(current, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(neighbor);\n                    visited.add(neighbor);\n                }\n            }\n        }\n\n        return traversalOrder;\n    }\n\n    public static void main(String[] args) {\n        BFSGraphTraversal graph = new BFSGraphTraversal();\n\n        // 添加图的边\n        graph.addEdge('A', 'B');\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'D');\n        graph.addEdge('B', 'E');\n        graph.addEdge('C', 'F');\n        graph.addEdge('E', 'F');\n\n        // 从节点 'A' 开始进行 BFS 遍历\n        List<Character> traversalOrder = graph.bfs('A');\n        System.out.println(\"BFS traversal order starting from node A: \" + traversalOrder);\n    }\n}\n\n\n```","slug":"高级算法/BFS","published":1,"date":"2024-07-10T10:07:16.855Z","updated":"2024-07-10T10:07:16.856Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlf0007ha8a3us98qhe","content":"<h1>BFS (Breadth-First Search)</h1>\n<h2 id=\"1-用途\">1. 用途</h2>\n<p>广度优先搜索（BFS）在现实中有许多实际用途，主要用于解决以下问题：</p>\n<ol>\n<li>最短路径搜索：BFS 可以用于无权图或者所有边权重相同的图中寻找最短路径。这在网络路由、社交网络中的最短友谊链、广告投放中的最短路径传播等方面有广泛应用。</li>\n<li>图的连通性检测：BFS 可以用来检测图是否是连通的，即从一个节点能否到达图中的所有其他节点。这在计算机网络中的连通性检测、社交网络中的社群发现等方面很有用。</li>\n<li>状态空间搜索：BFS 可以应用于状态空间搜索问题，如在迷宫游戏中找到从起点到终点的最短路径，或者在解决八皇后问题等排列组合问题时寻找最优解。</li>\n<li>Web爬虫：在网络爬虫中，BFS 用来抓取网页，并且可以限制爬取深度，确保优先爬取距离种子页面更近的链接。</li>\n<li>层次遍历：BFS 的特性使其适合进行层次遍历，例如<code>树的层次遍历</code>、多级菜单的展开等。</li>\n<li>游戏开发：在游戏开发中，BFS 可以用于寻找玩家或NPC的移动路径，或者在地图中寻找最近的敌人或资源。</li>\n</ol>\n<h2 id=\"2-代码\">2. 代码</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BFSGraphTraversal</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用邻接列表表示图</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;Character, List&lt;Character&gt;&gt; graph;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BFSGraphTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        graph = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加边的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(<span class=\"type\">char</span> from, <span class=\"type\">char</span> to)</span> &#123;</span><br><span class=\"line\">        graph.computeIfAbsent(from, k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()).add(to);</span><br><span class=\"line\">        graph.computeIfAbsent(to, k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()).add(from); <span class=\"comment\">// 如果是有向图，删除此行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// BFS 遍历方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Character&gt; <span class=\"title function_\">bfs</span><span class=\"params\">(<span class=\"type\">char</span> start)</span> &#123;</span><br><span class=\"line\">        List&lt;Character&gt; traversalOrder = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!graph.containsKey(start)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> traversalOrder;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Character&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Character&gt; visited = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.offer(start);</span><br><span class=\"line\">        visited.add(start);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            traversalOrder.add(current);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">char</span> neighbor : graph.getOrDefault(current, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class=\"line\">                    queue.offer(neighbor);</span><br><span class=\"line\">                    visited.add(neighbor);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> traversalOrder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BFSGraphTraversal</span> <span class=\"variable\">graph</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BFSGraphTraversal</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加图的边</span></span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从节点 &#x27;A&#x27; 开始进行 BFS 遍历</span></span><br><span class=\"line\">        List&lt;Character&gt; traversalOrder = graph.bfs(<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;BFS traversal order starting from node A: &quot;</span> + traversalOrder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h1>BFS (Breadth-First Search)</h1>\n<h2 id=\"1-用途\">1. 用途</h2>\n<p>广度优先搜索（BFS）在现实中有许多实际用途，主要用于解决以下问题：</p>\n<ol>\n<li>最短路径搜索：BFS 可以用于无权图或者所有边权重相同的图中寻找最短路径。这在网络路由、社交网络中的最短友谊链、广告投放中的最短路径传播等方面有广泛应用。</li>\n<li>图的连通性检测：BFS 可以用来检测图是否是连通的，即从一个节点能否到达图中的所有其他节点。这在计算机网络中的连通性检测、社交网络中的社群发现等方面很有用。</li>\n<li>状态空间搜索：BFS 可以应用于状态空间搜索问题，如在迷宫游戏中找到从起点到终点的最短路径，或者在解决八皇后问题等排列组合问题时寻找最优解。</li>\n<li>Web爬虫：在网络爬虫中，BFS 用来抓取网页，并且可以限制爬取深度，确保优先爬取距离种子页面更近的链接。</li>\n<li>层次遍历：BFS 的特性使其适合进行层次遍历，例如<code>树的层次遍历</code>、多级菜单的展开等。</li>\n<li>游戏开发：在游戏开发中，BFS 可以用于寻找玩家或NPC的移动路径，或者在地图中寻找最近的敌人或资源。</li>\n</ol>\n<h2 id=\"2-代码\">2. 代码</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BFSGraphTraversal</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用邻接列表表示图</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;Character, List&lt;Character&gt;&gt; graph;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BFSGraphTraversal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        graph = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加边的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(<span class=\"type\">char</span> from, <span class=\"type\">char</span> to)</span> &#123;</span><br><span class=\"line\">        graph.computeIfAbsent(from, k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()).add(to);</span><br><span class=\"line\">        graph.computeIfAbsent(to, k -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()).add(from); <span class=\"comment\">// 如果是有向图，删除此行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// BFS 遍历方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Character&gt; <span class=\"title function_\">bfs</span><span class=\"params\">(<span class=\"type\">char</span> start)</span> &#123;</span><br><span class=\"line\">        List&lt;Character&gt; traversalOrder = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!graph.containsKey(start)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> traversalOrder;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Character&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Character&gt; visited = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.offer(start);</span><br><span class=\"line\">        visited.add(start);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            traversalOrder.add(current);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">char</span> neighbor : graph.getOrDefault(current, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visited.contains(neighbor)) &#123;</span><br><span class=\"line\">                    queue.offer(neighbor);</span><br><span class=\"line\">                    visited.add(neighbor);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> traversalOrder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BFSGraphTraversal</span> <span class=\"variable\">graph</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BFSGraphTraversal</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 添加图的边</span></span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\">        graph.addEdge(<span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从节点 &#x27;A&#x27; 开始进行 BFS 遍历</span></span><br><span class=\"line\">        List&lt;Character&gt; traversalOrder = graph.bfs(<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;BFS traversal order starting from node A: &quot;</span> + traversalOrder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"greedy algorithm 贪心算法","weight":20,"_content":"\n## 1. 简述\n贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。\n比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。\n\n## 2. 应用\n\n贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码。","source":"_posts/高级算法/GreedyAlgorithm.md","raw":"---\ntitle: greedy algorithm 贪心算法\nweight: 20\n---\n\n## 1. 简述\n贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。\n比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。\n\n## 2. 应用\n\n贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码。","slug":"高级算法/GreedyAlgorithm","published":1,"date":"2024-07-12T10:57:46.832Z","updated":"2024-07-12T12:03:20.580Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlf0008ha8a5v6w6org","content":"<h2 id=\"1-简述\">1. 简述</h2>\n<p>贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。<br>\n比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p>\n<h2 id=\"2-应用\">2. 应用</h2>\n<p>贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码。</p>\n","excerpt":"","more":"<h2 id=\"1-简述\">1. 简述</h2>\n<p>贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。<br>\n比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p>\n<h2 id=\"2-应用\">2. 应用</h2>\n<p>贪心算法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码。</p>\n"},{"title":"P-NP问题","weight":10,"_content":"\n## P-NP问题\n### 1. 问题解释\n---\nP-NP问题是计算机科学中的一个著名难题。简单来说，它问的是：所有可以快速验证的答案，是否也可以快速找到？\n\n- P类问题是那些可以用计算机在多项式时间内（即相对较快）解决的问题。\n- NP类问题是那些答案可以在多项式时间内验证的问题，但我们不知道是否可以在同样的时间内找到这些答案。\n\n这个问题之所以重要，是因为如果证明P=NP，那么所有现在认为很难解决的问题都能很快解决。反之，如果P≠NP，那么有些问题是我们无法快速解决的。**换而言之就是当前所使用的这部分体系会被颠覆，需要重构**。\n\n\n### 2. 解决后果\n如果P=NP问题得到解决，并证明所有NP问题都可以在多项式时间内解决，将会对多个领域产生深远影响，特别是密码学领域。以下是可能的后果：\n\n1. 公钥加密\n- 现状： 目前的公钥加密（如RSA和椭圆曲线加密）依赖于一些数学难题（如大整数分解和离散对数问题）的难以解决性。这些问题目前被认为无法在多项式时间内解决，因此被广泛用于保护互联网通信和金融交易的安全。\n\n- 后果： 如果P=NP，那么这些问题可以在多项式时间内解决，从而使得公钥加密方案变得不再安全。任何人都可以在合理的时间内破解这些加密方案，从而可以解密敏感数据和窃取信息。\n\n2. 对称加密\n- 现状： 对称加密算法（如AES和3DES）依赖于密钥的难以破解性，目前认为这些算法在没有密钥的情况下很难被破解。\n- 后果： 如果P=NP，那么找到密钥变得容易，从而破坏对称加密的安全性。攻击者可以在多项式时间内找到正确的密钥，从而解密通信数据。\n\n3. 加密哈希\n- 现状： 加密哈希函数（如SHA-256）广泛用于数据完整性验证、数字签名和加密货币（如比特币）。这些哈希函数依赖于找到原像（给定哈希值找到相应输入）的难度。\n- 后果： 如果P=NP，找到哈希函数的前映像将变得简单，可以在多项式时间内完成，从而破坏加密哈希的安全性。攻击者可以伪造数据、生成冲突，甚至破坏区块链的完整性。\n\n4. 整体影响\n- 现状： 现代安全系统依赖于一些问题的计算复杂性，这些问题目前被认为在合理时间内无法解决。\n- 后果： 如果P=NP，所有依赖于计算复杂性的安全系统将变得不再可靠。需要开发新的基于信息论安全的解决方案，这些方案不依赖于计算复杂性假设。\n\n**替代方案**\n- 信息论安全： 这类安全方案在理论上是无懈可击的，不依赖于计算难题。例如，量子加密（如量子密钥分发）在理论上可以提供无条件的安全性。\n- 新算法： 研究者需要寻找新的算法和协议，这些算法和协议不依赖于现有的计算难题，可能涉及新的数学和理论基础。\n总结而言，如果P=NP被证明，将需要重新设计和实现现代密码系统，确保数据和通信的安全性。这个过程将是一个巨大的挑战，但也会推动计算机科学和密码学的进步。\n\n### 专业术语\nWhat are the differences between NP, NP-Complete and NP-Hard?\n\n\n1. NP（非确定性多项式时间）：\n\nNP类问题是指那些可以在多项式时间内由非确定性图灵机（Nondeterministic Turing Machine）解决的问题。\n换句话说，NP问题是那些解可以在多项式时间内验证的问题。\n例如，给定一个数独谜题（Sudoku puzzle）和一个解答，我们可以在多项式时间内验证这个解答是否正确。\n\n2. NP完全（NP-Complete）：\n\nNP完全问题是NP类问题中的一个子集，具有以下两个特性：\n该问题本身是NP问题。\n任何NP问题都可以在多项式时间内归约（转换）为这个问题。\n这意味着，如果我们能够在多项式时间内解决任何一个NP完全问题，那么所有NP问题都可以在多项式时间内解决。\n例如，旅行推销员问题（Traveling Salesman Problem, TSP）是一个经典的NP完全问题。\n\n3. NP困难（NP-Hard）：\n\nNP困难问题是那些至少和NP问题一样难的问题。\n这些问题不一定是NP问题，也就是说，NP困难问题的解不一定能在多项式时间内验证。\n例如，计算一个图的最大团（Maximal Clique）是一个NP困难问题，它不仅是一个很难解决的问题，而且我们也不能在多项式时间内验证其解的正确性。\n**举个例子：**\n假设我们有一个物流公司的运输问题：\n\nNP问题：判断是否存在一种路径，使得运输成本不超过某个给定的预算。验证一条具体的路径是否满足这个条件是可以在多项式时间内完成的，因此这是一个NP问题。\n\nNP完全问题：在上述运输问题中，找到一条确切的路径，使得运输成本正好等于预算，并且是最短的路径。这可以归约为旅行推销员问题（TSP），所以这是一个NP完全问题。\n\nNP困难问题：假设这个物流公司想要最优地安排车辆，以最小化所有可能路径的总运输成本，这涉及到图论中的车辆路径问题（Vehicle Routing Problem, VRP），这是一个NP困难问题，因为它不仅难以解决，而且即使找到一个解，也无法在多项式时间内验证其最优性。\n\n\n### 问题\nIn comparing NP-complete and NP-hard, which of the following statements are TRUE?\n\ni） The theory of NP-completeness provides a method of obtaining a polynomial time for NP algorithms.\nii） All NP-complete problems are NP-Hard.","source":"_posts/高级算法/P-NP问题.md","raw":"---\ntitle: P-NP问题\nweight: 10\n---\n\n## P-NP问题\n### 1. 问题解释\n---\nP-NP问题是计算机科学中的一个著名难题。简单来说，它问的是：所有可以快速验证的答案，是否也可以快速找到？\n\n- P类问题是那些可以用计算机在多项式时间内（即相对较快）解决的问题。\n- NP类问题是那些答案可以在多项式时间内验证的问题，但我们不知道是否可以在同样的时间内找到这些答案。\n\n这个问题之所以重要，是因为如果证明P=NP，那么所有现在认为很难解决的问题都能很快解决。反之，如果P≠NP，那么有些问题是我们无法快速解决的。**换而言之就是当前所使用的这部分体系会被颠覆，需要重构**。\n\n\n### 2. 解决后果\n如果P=NP问题得到解决，并证明所有NP问题都可以在多项式时间内解决，将会对多个领域产生深远影响，特别是密码学领域。以下是可能的后果：\n\n1. 公钥加密\n- 现状： 目前的公钥加密（如RSA和椭圆曲线加密）依赖于一些数学难题（如大整数分解和离散对数问题）的难以解决性。这些问题目前被认为无法在多项式时间内解决，因此被广泛用于保护互联网通信和金融交易的安全。\n\n- 后果： 如果P=NP，那么这些问题可以在多项式时间内解决，从而使得公钥加密方案变得不再安全。任何人都可以在合理的时间内破解这些加密方案，从而可以解密敏感数据和窃取信息。\n\n2. 对称加密\n- 现状： 对称加密算法（如AES和3DES）依赖于密钥的难以破解性，目前认为这些算法在没有密钥的情况下很难被破解。\n- 后果： 如果P=NP，那么找到密钥变得容易，从而破坏对称加密的安全性。攻击者可以在多项式时间内找到正确的密钥，从而解密通信数据。\n\n3. 加密哈希\n- 现状： 加密哈希函数（如SHA-256）广泛用于数据完整性验证、数字签名和加密货币（如比特币）。这些哈希函数依赖于找到原像（给定哈希值找到相应输入）的难度。\n- 后果： 如果P=NP，找到哈希函数的前映像将变得简单，可以在多项式时间内完成，从而破坏加密哈希的安全性。攻击者可以伪造数据、生成冲突，甚至破坏区块链的完整性。\n\n4. 整体影响\n- 现状： 现代安全系统依赖于一些问题的计算复杂性，这些问题目前被认为在合理时间内无法解决。\n- 后果： 如果P=NP，所有依赖于计算复杂性的安全系统将变得不再可靠。需要开发新的基于信息论安全的解决方案，这些方案不依赖于计算复杂性假设。\n\n**替代方案**\n- 信息论安全： 这类安全方案在理论上是无懈可击的，不依赖于计算难题。例如，量子加密（如量子密钥分发）在理论上可以提供无条件的安全性。\n- 新算法： 研究者需要寻找新的算法和协议，这些算法和协议不依赖于现有的计算难题，可能涉及新的数学和理论基础。\n总结而言，如果P=NP被证明，将需要重新设计和实现现代密码系统，确保数据和通信的安全性。这个过程将是一个巨大的挑战，但也会推动计算机科学和密码学的进步。\n\n### 专业术语\nWhat are the differences between NP, NP-Complete and NP-Hard?\n\n\n1. NP（非确定性多项式时间）：\n\nNP类问题是指那些可以在多项式时间内由非确定性图灵机（Nondeterministic Turing Machine）解决的问题。\n换句话说，NP问题是那些解可以在多项式时间内验证的问题。\n例如，给定一个数独谜题（Sudoku puzzle）和一个解答，我们可以在多项式时间内验证这个解答是否正确。\n\n2. NP完全（NP-Complete）：\n\nNP完全问题是NP类问题中的一个子集，具有以下两个特性：\n该问题本身是NP问题。\n任何NP问题都可以在多项式时间内归约（转换）为这个问题。\n这意味着，如果我们能够在多项式时间内解决任何一个NP完全问题，那么所有NP问题都可以在多项式时间内解决。\n例如，旅行推销员问题（Traveling Salesman Problem, TSP）是一个经典的NP完全问题。\n\n3. NP困难（NP-Hard）：\n\nNP困难问题是那些至少和NP问题一样难的问题。\n这些问题不一定是NP问题，也就是说，NP困难问题的解不一定能在多项式时间内验证。\n例如，计算一个图的最大团（Maximal Clique）是一个NP困难问题，它不仅是一个很难解决的问题，而且我们也不能在多项式时间内验证其解的正确性。\n**举个例子：**\n假设我们有一个物流公司的运输问题：\n\nNP问题：判断是否存在一种路径，使得运输成本不超过某个给定的预算。验证一条具体的路径是否满足这个条件是可以在多项式时间内完成的，因此这是一个NP问题。\n\nNP完全问题：在上述运输问题中，找到一条确切的路径，使得运输成本正好等于预算，并且是最短的路径。这可以归约为旅行推销员问题（TSP），所以这是一个NP完全问题。\n\nNP困难问题：假设这个物流公司想要最优地安排车辆，以最小化所有可能路径的总运输成本，这涉及到图论中的车辆路径问题（Vehicle Routing Problem, VRP），这是一个NP困难问题，因为它不仅难以解决，而且即使找到一个解，也无法在多项式时间内验证其最优性。\n\n\n### 问题\nIn comparing NP-complete and NP-hard, which of the following statements are TRUE?\n\ni） The theory of NP-completeness provides a method of obtaining a polynomial time for NP algorithms.\nii） All NP-complete problems are NP-Hard.","slug":"高级算法/P-NP问题","published":1,"date":"2024-07-10T10:07:16.873Z","updated":"2024-07-10T10:07:16.874Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlg0009ha8a1rm0e8gm","content":"<h2 id=\"P-NP问题\">P-NP问题</h2>\n<h3 id=\"1-问题解释\">1. 问题解释</h3>\n<hr>\n<p>P-NP问题是计算机科学中的一个著名难题。简单来说，它问的是：所有可以快速验证的答案，是否也可以快速找到？</p>\n<ul>\n<li>P类问题是那些可以用计算机在多项式时间内（即相对较快）解决的问题。</li>\n<li>NP类问题是那些答案可以在多项式时间内验证的问题，但我们不知道是否可以在同样的时间内找到这些答案。</li>\n</ul>\n<p>这个问题之所以重要，是因为如果证明P=NP，那么所有现在认为很难解决的问题都能很快解决。反之，如果P≠NP，那么有些问题是我们无法快速解决的。<strong>换而言之就是当前所使用的这部分体系会被颠覆，需要重构</strong>。</p>\n<h3 id=\"2-解决后果\">2. 解决后果</h3>\n<p>如果P=NP问题得到解决，并证明所有NP问题都可以在多项式时间内解决，将会对多个领域产生深远影响，特别是密码学领域。以下是可能的后果：</p>\n<ol>\n<li>公钥加密</li>\n</ol>\n<ul>\n<li>\n<p>现状： 目前的公钥加密（如RSA和椭圆曲线加密）依赖于一些数学难题（如大整数分解和离散对数问题）的难以解决性。这些问题目前被认为无法在多项式时间内解决，因此被广泛用于保护互联网通信和金融交易的安全。</p>\n</li>\n<li>\n<p>后果： 如果P=NP，那么这些问题可以在多项式时间内解决，从而使得公钥加密方案变得不再安全。任何人都可以在合理的时间内破解这些加密方案，从而可以解密敏感数据和窃取信息。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>对称加密</li>\n</ol>\n<ul>\n<li>现状： 对称加密算法（如AES和3DES）依赖于密钥的难以破解性，目前认为这些算法在没有密钥的情况下很难被破解。</li>\n<li>后果： 如果P=NP，那么找到密钥变得容易，从而破坏对称加密的安全性。攻击者可以在多项式时间内找到正确的密钥，从而解密通信数据。</li>\n</ul>\n<ol start=\"3\">\n<li>加密哈希</li>\n</ol>\n<ul>\n<li>现状： 加密哈希函数（如SHA-256）广泛用于数据完整性验证、数字签名和加密货币（如比特币）。这些哈希函数依赖于找到原像（给定哈希值找到相应输入）的难度。</li>\n<li>后果： 如果P=NP，找到哈希函数的前映像将变得简单，可以在多项式时间内完成，从而破坏加密哈希的安全性。攻击者可以伪造数据、生成冲突，甚至破坏区块链的完整性。</li>\n</ul>\n<ol start=\"4\">\n<li>整体影响</li>\n</ol>\n<ul>\n<li>现状： 现代安全系统依赖于一些问题的计算复杂性，这些问题目前被认为在合理时间内无法解决。</li>\n<li>后果： 如果P=NP，所有依赖于计算复杂性的安全系统将变得不再可靠。需要开发新的基于信息论安全的解决方案，这些方案不依赖于计算复杂性假设。</li>\n</ul>\n<p><strong>替代方案</strong></p>\n<ul>\n<li>信息论安全： 这类安全方案在理论上是无懈可击的，不依赖于计算难题。例如，量子加密（如量子密钥分发）在理论上可以提供无条件的安全性。</li>\n<li>新算法： 研究者需要寻找新的算法和协议，这些算法和协议不依赖于现有的计算难题，可能涉及新的数学和理论基础。<br>\n总结而言，如果P=NP被证明，将需要重新设计和实现现代密码系统，确保数据和通信的安全性。这个过程将是一个巨大的挑战，但也会推动计算机科学和密码学的进步。</li>\n</ul>\n<h3 id=\"专业术语\">专业术语</h3>\n<p>What are the differences between NP, NP-Complete and NP-Hard?</p>\n<ol>\n<li>NP（非确定性多项式时间）：</li>\n</ol>\n<p>NP类问题是指那些可以在多项式时间内由非确定性图灵机（Nondeterministic Turing Machine）解决的问题。<br>\n换句话说，NP问题是那些解可以在多项式时间内验证的问题。<br>\n例如，给定一个数独谜题（Sudoku puzzle）和一个解答，我们可以在多项式时间内验证这个解答是否正确。</p>\n<ol start=\"2\">\n<li>NP完全（NP-Complete）：</li>\n</ol>\n<p>NP完全问题是NP类问题中的一个子集，具有以下两个特性：<br>\n该问题本身是NP问题。<br>\n任何NP问题都可以在多项式时间内归约（转换）为这个问题。<br>\n这意味着，如果我们能够在多项式时间内解决任何一个NP完全问题，那么所有NP问题都可以在多项式时间内解决。<br>\n例如，旅行推销员问题（Traveling Salesman Problem, TSP）是一个经典的NP完全问题。</p>\n<ol start=\"3\">\n<li>NP困难（NP-Hard）：</li>\n</ol>\n<p>NP困难问题是那些至少和NP问题一样难的问题。<br>\n这些问题不一定是NP问题，也就是说，NP困难问题的解不一定能在多项式时间内验证。<br>\n例如，计算一个图的最大团（Maximal Clique）是一个NP困难问题，它不仅是一个很难解决的问题，而且我们也不能在多项式时间内验证其解的正确性。<br>\n<strong>举个例子：</strong><br>\n假设我们有一个物流公司的运输问题：</p>\n<p>NP问题：判断是否存在一种路径，使得运输成本不超过某个给定的预算。验证一条具体的路径是否满足这个条件是可以在多项式时间内完成的，因此这是一个NP问题。</p>\n<p>NP完全问题：在上述运输问题中，找到一条确切的路径，使得运输成本正好等于预算，并且是最短的路径。这可以归约为旅行推销员问题（TSP），所以这是一个NP完全问题。</p>\n<p>NP困难问题：假设这个物流公司想要最优地安排车辆，以最小化所有可能路径的总运输成本，这涉及到图论中的车辆路径问题（Vehicle Routing Problem, VRP），这是一个NP困难问题，因为它不仅难以解决，而且即使找到一个解，也无法在多项式时间内验证其最优性。</p>\n<h3 id=\"问题\">问题</h3>\n<p>In comparing NP-complete and NP-hard, which of the following statements are TRUE?</p>\n<p>i） The theory of NP-completeness provides a method of obtaining a polynomial time for NP algorithms.<br>\nii） All NP-complete problems are NP-Hard.</p>\n","excerpt":"","more":"<h2 id=\"P-NP问题\">P-NP问题</h2>\n<h3 id=\"1-问题解释\">1. 问题解释</h3>\n<hr>\n<p>P-NP问题是计算机科学中的一个著名难题。简单来说，它问的是：所有可以快速验证的答案，是否也可以快速找到？</p>\n<ul>\n<li>P类问题是那些可以用计算机在多项式时间内（即相对较快）解决的问题。</li>\n<li>NP类问题是那些答案可以在多项式时间内验证的问题，但我们不知道是否可以在同样的时间内找到这些答案。</li>\n</ul>\n<p>这个问题之所以重要，是因为如果证明P=NP，那么所有现在认为很难解决的问题都能很快解决。反之，如果P≠NP，那么有些问题是我们无法快速解决的。<strong>换而言之就是当前所使用的这部分体系会被颠覆，需要重构</strong>。</p>\n<h3 id=\"2-解决后果\">2. 解决后果</h3>\n<p>如果P=NP问题得到解决，并证明所有NP问题都可以在多项式时间内解决，将会对多个领域产生深远影响，特别是密码学领域。以下是可能的后果：</p>\n<ol>\n<li>公钥加密</li>\n</ol>\n<ul>\n<li>\n<p>现状： 目前的公钥加密（如RSA和椭圆曲线加密）依赖于一些数学难题（如大整数分解和离散对数问题）的难以解决性。这些问题目前被认为无法在多项式时间内解决，因此被广泛用于保护互联网通信和金融交易的安全。</p>\n</li>\n<li>\n<p>后果： 如果P=NP，那么这些问题可以在多项式时间内解决，从而使得公钥加密方案变得不再安全。任何人都可以在合理的时间内破解这些加密方案，从而可以解密敏感数据和窃取信息。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>对称加密</li>\n</ol>\n<ul>\n<li>现状： 对称加密算法（如AES和3DES）依赖于密钥的难以破解性，目前认为这些算法在没有密钥的情况下很难被破解。</li>\n<li>后果： 如果P=NP，那么找到密钥变得容易，从而破坏对称加密的安全性。攻击者可以在多项式时间内找到正确的密钥，从而解密通信数据。</li>\n</ul>\n<ol start=\"3\">\n<li>加密哈希</li>\n</ol>\n<ul>\n<li>现状： 加密哈希函数（如SHA-256）广泛用于数据完整性验证、数字签名和加密货币（如比特币）。这些哈希函数依赖于找到原像（给定哈希值找到相应输入）的难度。</li>\n<li>后果： 如果P=NP，找到哈希函数的前映像将变得简单，可以在多项式时间内完成，从而破坏加密哈希的安全性。攻击者可以伪造数据、生成冲突，甚至破坏区块链的完整性。</li>\n</ul>\n<ol start=\"4\">\n<li>整体影响</li>\n</ol>\n<ul>\n<li>现状： 现代安全系统依赖于一些问题的计算复杂性，这些问题目前被认为在合理时间内无法解决。</li>\n<li>后果： 如果P=NP，所有依赖于计算复杂性的安全系统将变得不再可靠。需要开发新的基于信息论安全的解决方案，这些方案不依赖于计算复杂性假设。</li>\n</ul>\n<p><strong>替代方案</strong></p>\n<ul>\n<li>信息论安全： 这类安全方案在理论上是无懈可击的，不依赖于计算难题。例如，量子加密（如量子密钥分发）在理论上可以提供无条件的安全性。</li>\n<li>新算法： 研究者需要寻找新的算法和协议，这些算法和协议不依赖于现有的计算难题，可能涉及新的数学和理论基础。<br>\n总结而言，如果P=NP被证明，将需要重新设计和实现现代密码系统，确保数据和通信的安全性。这个过程将是一个巨大的挑战，但也会推动计算机科学和密码学的进步。</li>\n</ul>\n<h3 id=\"专业术语\">专业术语</h3>\n<p>What are the differences between NP, NP-Complete and NP-Hard?</p>\n<ol>\n<li>NP（非确定性多项式时间）：</li>\n</ol>\n<p>NP类问题是指那些可以在多项式时间内由非确定性图灵机（Nondeterministic Turing Machine）解决的问题。<br>\n换句话说，NP问题是那些解可以在多项式时间内验证的问题。<br>\n例如，给定一个数独谜题（Sudoku puzzle）和一个解答，我们可以在多项式时间内验证这个解答是否正确。</p>\n<ol start=\"2\">\n<li>NP完全（NP-Complete）：</li>\n</ol>\n<p>NP完全问题是NP类问题中的一个子集，具有以下两个特性：<br>\n该问题本身是NP问题。<br>\n任何NP问题都可以在多项式时间内归约（转换）为这个问题。<br>\n这意味着，如果我们能够在多项式时间内解决任何一个NP完全问题，那么所有NP问题都可以在多项式时间内解决。<br>\n例如，旅行推销员问题（Traveling Salesman Problem, TSP）是一个经典的NP完全问题。</p>\n<ol start=\"3\">\n<li>NP困难（NP-Hard）：</li>\n</ol>\n<p>NP困难问题是那些至少和NP问题一样难的问题。<br>\n这些问题不一定是NP问题，也就是说，NP困难问题的解不一定能在多项式时间内验证。<br>\n例如，计算一个图的最大团（Maximal Clique）是一个NP困难问题，它不仅是一个很难解决的问题，而且我们也不能在多项式时间内验证其解的正确性。<br>\n<strong>举个例子：</strong><br>\n假设我们有一个物流公司的运输问题：</p>\n<p>NP问题：判断是否存在一种路径，使得运输成本不超过某个给定的预算。验证一条具体的路径是否满足这个条件是可以在多项式时间内完成的，因此这是一个NP问题。</p>\n<p>NP完全问题：在上述运输问题中，找到一条确切的路径，使得运输成本正好等于预算，并且是最短的路径。这可以归约为旅行推销员问题（TSP），所以这是一个NP完全问题。</p>\n<p>NP困难问题：假设这个物流公司想要最优地安排车辆，以最小化所有可能路径的总运输成本，这涉及到图论中的车辆路径问题（Vehicle Routing Problem, VRP），这是一个NP困难问题，因为它不仅难以解决，而且即使找到一个解，也无法在多项式时间内验证其最优性。</p>\n<h3 id=\"问题\">问题</h3>\n<p>In comparing NP-complete and NP-hard, which of the following statements are TRUE?</p>\n<p>i） The theory of NP-completeness provides a method of obtaining a polynomial time for NP algorithms.<br>\nii） All NP-complete problems are NP-Hard.</p>\n"},{"title":"最小生成树·Prim Jarnik algorithm","weight":10,"_content":"\n","source":"_posts/高级算法/PrimJarnik算法.md","raw":"---\ntitle: 最小生成树·Prim Jarnik algorithm\nweight: 10\n---\n\n","slug":"高级算法/PrimJarnik算法","published":1,"date":"2024-07-12T10:35:49.512Z","updated":"2024-07-12T10:36:23.243Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlg000aha8a5fqc1yic","content":"","excerpt":"","more":""},{"title":"图论","_content":"\n## 1. Disconnected Graph (图形不连通 / 断开图)\n\nEnglish: A graph in which there are at least two vertices such that there is no path connecting them.\n中文: 一个图中至少有两个顶点之间没有路径相连。\n\n```\nA---B         E---F\n    |\n    C---D\n```\n\n## 2. Bipartite Graph (二部图 / 二分图)\n`bipartite ［bipartit］; adj. 二深裂的［指叶子］；由双方组成的，两党的，由两党组成的.`\n\nEnglish: A graph whose vertices can be divided into two disjoint and independent sets such that every edge connects a vertex in one set to a vertex in the other set.\n中文: 将顶点分成两类，边只存在不同类的顶点之间，同类顶点之间没有边。\n\n**应用：**\n\n二部图在许多领域的应用中非常常见，包括：\n\n* 最大匹配问题：寻找图中不存在共用顶点的最大边集。\n\n* 婚姻问题：将 n 位女士与 n 位男士配对，使得每位女士都嫁给一位男士，每位男士都娶一位女士。\n\n* 流量网络：表示商品在网络中从源点到汇点的流动。\n\n```\nSet 1: A, C, E\nSet 2: B, D, F\n\n  A--B\n   \\/\n   /\\\n  C--D\n   \\/\n   /\\\n  E--F\n\n```\n\n## 3. Planar Graph (平面图)\n\nEnglish: A graph that can be drawn on a plane without any edges crossing each other.\n中文: 一种图，可以在平面上绘制而`不`出现任何边`交叉`。\n\n```\n    A\n   / \\\n  /   \\\n B-----C\n |     |\n D-----E\n\n```\n\n## 4. Subgraph (子图)\n\nEnglish: A graph formed from a subset of the vertices and edges of another graph.\n中文: 从另一个图的顶点和边的子集中形成的图。（可以没有一些边和点）\n```\nOriginal Graph:\nA---B---C\n|       |\nD---E---F\n\nSubgraph:\nA---B\n|  \nD---E\n\n```\n\n\n## 5. Spanning Subgraph (生成子图)\n`中古高地德語 spān ← 古高地德語 spān (“木屑，削片”) ← 原始日耳曼語 *spēnuz (“碎屑，削片”)。 与古英語 spōn (“木片，碎屑”)同源`\nEnglish: A subgraph that includes all the vertices of the original graph.\n中文: 包含原图所有顶点的子图。（可以没有一些边，但不能少点）\n\n```\nOriginal Graph:\nA---B\n|   |\nC---D---E\n\nSpanning Subgraph:\nA---B\n|  \nC---D---E\n\n```\n\n## 6. Separation edges and separation vertices\n","source":"_posts/高级算法/图论.md","raw":"---\ntitle: 图论\n---\n\n## 1. Disconnected Graph (图形不连通 / 断开图)\n\nEnglish: A graph in which there are at least two vertices such that there is no path connecting them.\n中文: 一个图中至少有两个顶点之间没有路径相连。\n\n```\nA---B         E---F\n    |\n    C---D\n```\n\n## 2. Bipartite Graph (二部图 / 二分图)\n`bipartite ［bipartit］; adj. 二深裂的［指叶子］；由双方组成的，两党的，由两党组成的.`\n\nEnglish: A graph whose vertices can be divided into two disjoint and independent sets such that every edge connects a vertex in one set to a vertex in the other set.\n中文: 将顶点分成两类，边只存在不同类的顶点之间，同类顶点之间没有边。\n\n**应用：**\n\n二部图在许多领域的应用中非常常见，包括：\n\n* 最大匹配问题：寻找图中不存在共用顶点的最大边集。\n\n* 婚姻问题：将 n 位女士与 n 位男士配对，使得每位女士都嫁给一位男士，每位男士都娶一位女士。\n\n* 流量网络：表示商品在网络中从源点到汇点的流动。\n\n```\nSet 1: A, C, E\nSet 2: B, D, F\n\n  A--B\n   \\/\n   /\\\n  C--D\n   \\/\n   /\\\n  E--F\n\n```\n\n## 3. Planar Graph (平面图)\n\nEnglish: A graph that can be drawn on a plane without any edges crossing each other.\n中文: 一种图，可以在平面上绘制而`不`出现任何边`交叉`。\n\n```\n    A\n   / \\\n  /   \\\n B-----C\n |     |\n D-----E\n\n```\n\n## 4. Subgraph (子图)\n\nEnglish: A graph formed from a subset of the vertices and edges of another graph.\n中文: 从另一个图的顶点和边的子集中形成的图。（可以没有一些边和点）\n```\nOriginal Graph:\nA---B---C\n|       |\nD---E---F\n\nSubgraph:\nA---B\n|  \nD---E\n\n```\n\n\n## 5. Spanning Subgraph (生成子图)\n`中古高地德語 spān ← 古高地德語 spān (“木屑，削片”) ← 原始日耳曼語 *spēnuz (“碎屑，削片”)。 与古英語 spōn (“木片，碎屑”)同源`\nEnglish: A subgraph that includes all the vertices of the original graph.\n中文: 包含原图所有顶点的子图。（可以没有一些边，但不能少点）\n\n```\nOriginal Graph:\nA---B\n|   |\nC---D---E\n\nSpanning Subgraph:\nA---B\n|  \nC---D---E\n\n```\n\n## 6. Separation edges and separation vertices\n","slug":"高级算法/图论","published":1,"date":"2024-07-10T08:14:31.325Z","updated":"2024-07-12T08:49:14.489Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtli000bha8ad0n38vgw","content":"<h2 id=\"1-Disconnected-Graph-图形不连通-断开图\">1. Disconnected Graph (图形不连通 / 断开图)</h2>\n<p>English: A graph in which there are at least two vertices such that there is no path connecting them.<br>\n中文: 一个图中至少有两个顶点之间没有路径相连。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A---B         E---F</span><br><span class=\"line\">    |</span><br><span class=\"line\">    C---D</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Bipartite-Graph-二部图-二分图\">2. Bipartite Graph (二部图 / 二分图)</h2>\n<p><code>bipartite ［bipartit］; adj. 二深裂的［指叶子］；由双方组成的，两党的，由两党组成的.</code></p>\n<p>English: A graph whose vertices can be divided into two disjoint and independent sets such that every edge connects a vertex in one set to a vertex in the other set.<br>\n中文: 将顶点分成两类，边只存在不同类的顶点之间，同类顶点之间没有边。</p>\n<p><strong>应用：</strong></p>\n<p>二部图在许多领域的应用中非常常见，包括：</p>\n<ul>\n<li>\n<p>最大匹配问题：寻找图中不存在共用顶点的最大边集。</p>\n</li>\n<li>\n<p>婚姻问题：将 n 位女士与 n 位男士配对，使得每位女士都嫁给一位男士，每位男士都娶一位女士。</p>\n</li>\n<li>\n<p>流量网络：表示商品在网络中从源点到汇点的流动。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set 1: A, C, E</span><br><span class=\"line\">Set 2: B, D, F</span><br><span class=\"line\"></span><br><span class=\"line\">  A--B</span><br><span class=\"line\">   \\/</span><br><span class=\"line\">   /\\</span><br><span class=\"line\">  C--D</span><br><span class=\"line\">   \\/</span><br><span class=\"line\">   /\\</span><br><span class=\"line\">  E--F</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Planar-Graph-平面图\">3. Planar Graph (平面图)</h2>\n<p>English: A graph that can be drawn on a plane without any edges crossing each other.<br>\n中文: 一种图，可以在平面上绘制而<code>不</code>出现任何边<code>交叉</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   A</span><br><span class=\"line\">  / \\</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">B-----C</span><br><span class=\"line\">|     |</span><br><span class=\"line\">D-----E</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Subgraph-子图\">4. Subgraph (子图)</h2>\n<p>English: A graph formed from a subset of the vertices and edges of another graph.<br>\n中文: 从另一个图的顶点和边的子集中形成的图。（可以没有一些边和点）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Original Graph:</span><br><span class=\"line\">A---B---C</span><br><span class=\"line\">|       |</span><br><span class=\"line\">D---E---F</span><br><span class=\"line\"></span><br><span class=\"line\">Subgraph:</span><br><span class=\"line\">A---B</span><br><span class=\"line\">|  </span><br><span class=\"line\">D---E</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Spanning-Subgraph-生成子图\">5. Spanning Subgraph (生成子图)</h2>\n<p><code>中古高地德語 spān ← 古高地德語 spān (“木屑，削片”) ← 原始日耳曼語 *spēnuz (“碎屑，削片”)。 与古英語 spōn (“木片，碎屑”)同源</code><br>\nEnglish: A subgraph that includes all the vertices of the original graph.<br>\n中文: 包含原图所有顶点的子图。（可以没有一些边，但不能少点）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Original Graph:</span><br><span class=\"line\">A---B</span><br><span class=\"line\">|   |</span><br><span class=\"line\">C---D---E</span><br><span class=\"line\"></span><br><span class=\"line\">Spanning Subgraph:</span><br><span class=\"line\">A---B</span><br><span class=\"line\">|  </span><br><span class=\"line\">C---D---E</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-Separation-edges-and-separation-vertices\">6. Separation edges and separation vertices</h2>\n","excerpt":"","more":"<h2 id=\"1-Disconnected-Graph-图形不连通-断开图\">1. Disconnected Graph (图形不连通 / 断开图)</h2>\n<p>English: A graph in which there are at least two vertices such that there is no path connecting them.<br>\n中文: 一个图中至少有两个顶点之间没有路径相连。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A---B         E---F</span><br><span class=\"line\">    |</span><br><span class=\"line\">    C---D</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Bipartite-Graph-二部图-二分图\">2. Bipartite Graph (二部图 / 二分图)</h2>\n<p><code>bipartite ［bipartit］; adj. 二深裂的［指叶子］；由双方组成的，两党的，由两党组成的.</code></p>\n<p>English: A graph whose vertices can be divided into two disjoint and independent sets such that every edge connects a vertex in one set to a vertex in the other set.<br>\n中文: 将顶点分成两类，边只存在不同类的顶点之间，同类顶点之间没有边。</p>\n<p><strong>应用：</strong></p>\n<p>二部图在许多领域的应用中非常常见，包括：</p>\n<ul>\n<li>\n<p>最大匹配问题：寻找图中不存在共用顶点的最大边集。</p>\n</li>\n<li>\n<p>婚姻问题：将 n 位女士与 n 位男士配对，使得每位女士都嫁给一位男士，每位男士都娶一位女士。</p>\n</li>\n<li>\n<p>流量网络：表示商品在网络中从源点到汇点的流动。</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set 1: A, C, E</span><br><span class=\"line\">Set 2: B, D, F</span><br><span class=\"line\"></span><br><span class=\"line\">  A--B</span><br><span class=\"line\">   \\/</span><br><span class=\"line\">   /\\</span><br><span class=\"line\">  C--D</span><br><span class=\"line\">   \\/</span><br><span class=\"line\">   /\\</span><br><span class=\"line\">  E--F</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-Planar-Graph-平面图\">3. Planar Graph (平面图)</h2>\n<p>English: A graph that can be drawn on a plane without any edges crossing each other.<br>\n中文: 一种图，可以在平面上绘制而<code>不</code>出现任何边<code>交叉</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   A</span><br><span class=\"line\">  / \\</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">B-----C</span><br><span class=\"line\">|     |</span><br><span class=\"line\">D-----E</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Subgraph-子图\">4. Subgraph (子图)</h2>\n<p>English: A graph formed from a subset of the vertices and edges of another graph.<br>\n中文: 从另一个图的顶点和边的子集中形成的图。（可以没有一些边和点）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Original Graph:</span><br><span class=\"line\">A---B---C</span><br><span class=\"line\">|       |</span><br><span class=\"line\">D---E---F</span><br><span class=\"line\"></span><br><span class=\"line\">Subgraph:</span><br><span class=\"line\">A---B</span><br><span class=\"line\">|  </span><br><span class=\"line\">D---E</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Spanning-Subgraph-生成子图\">5. Spanning Subgraph (生成子图)</h2>\n<p><code>中古高地德語 spān ← 古高地德語 spān (“木屑，削片”) ← 原始日耳曼語 *spēnuz (“碎屑，削片”)。 与古英語 spōn (“木片，碎屑”)同源</code><br>\nEnglish: A subgraph that includes all the vertices of the original graph.<br>\n中文: 包含原图所有顶点的子图。（可以没有一些边，但不能少点）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Original Graph:</span><br><span class=\"line\">A---B</span><br><span class=\"line\">|   |</span><br><span class=\"line\">C---D---E</span><br><span class=\"line\"></span><br><span class=\"line\">Spanning Subgraph:</span><br><span class=\"line\">A---B</span><br><span class=\"line\">|  </span><br><span class=\"line\">C---D---E</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-Separation-edges-and-separation-vertices\">6. Separation edges and separation vertices</h2>\n"},{"_content":"## Stack\n\n### 特点：\n- LIFO（Last In, First Out）：最后进来的元素最先被处理。\n- 常用操作：push（入栈）、pop（出栈）、peek（查看栈顶元素）。\n\n### 性能：\n- 入栈（push）和出栈（pop）：时间复杂度为 O(1)。\n- 空间复杂度：与存储的元素数量成正比，为 O(n)。\n\n### 优势：\n- 操作简单，适用于需要后进先出（LIFO）策略的场景，如函数调用栈、表达式求值等。\n- 内存使用效率高。\n\n### 劣势：\n- 访问非栈顶元素效率低，需要遍历。\n\n## Queue\n\n### 特点：\n- FIFO（First In, First Out）：最先进来的元素最先被处理。\n- 常用操作：enqueue（入队）、dequeue（出队）、peek（查看队首元素）。\n\n### 性能：\n- 入队（enqueue）和出队（dequeue）：时间复杂度为 O(1)（使用链表或循环数组实现时）。\n- 空间复杂度：与存储的元素数量成正比，为 O(n)。\n\n### 优势：\n- 适用于需要先进先出（FIFO）策略的场景，如任务调度、缓冲区管理等。\n- 操作简单，入队和出队操作效率高。\n\n### 劣势：\n- 访问非队首元素效率低，需要遍历。\n\n## PriorityQueue\n\n### 特点：\n- 元素按照优先级顺序进行出队，优先级高的元素先出队。\n- 常用操作：insert（插入元素）、remove（移除元素）、peek（查看优先级最高的元素）。\n\n### 性能：\n- 插入（insert）：时间复杂度为 O(log n)（使用二叉堆实现时）。\n- 删除（remove）：时间复杂度为 O(log n)（删除优先级最高的元素）。\n- 查看优先级最高元素（peek）：时间复杂度为 O(1)。\n\n### 优势：\n- 适用于需要动态管理元素优先级的场景，如任务调度、路径规划（如Dijkstra算法）、事件驱动模拟等。\n- 可以快速获取和删除优先级最高的元素。\n\n### 劣势：\n- 插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。\n- 需要维护优先级，内存开销可能较大。\n\n## 总结\n\n- Stack：适用于需要 LIFO 策略的场景，入栈和出栈操作效率高（O(1)），但访问非栈顶元素效率低。\n- Queue：适用于需要 FIFO 策略的场景，入队和出队操作效率高（O(1)），但访问非队首元素效率低。\n- PriorityQueue：适用于需要根据优先级动态管理元素的场景，可以快速获取和删除优先级最高的元素（O(log n)），但插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。\n","source":"_posts/高级算法/队栈.md","raw":"## Stack\n\n### 特点：\n- LIFO（Last In, First Out）：最后进来的元素最先被处理。\n- 常用操作：push（入栈）、pop（出栈）、peek（查看栈顶元素）。\n\n### 性能：\n- 入栈（push）和出栈（pop）：时间复杂度为 O(1)。\n- 空间复杂度：与存储的元素数量成正比，为 O(n)。\n\n### 优势：\n- 操作简单，适用于需要后进先出（LIFO）策略的场景，如函数调用栈、表达式求值等。\n- 内存使用效率高。\n\n### 劣势：\n- 访问非栈顶元素效率低，需要遍历。\n\n## Queue\n\n### 特点：\n- FIFO（First In, First Out）：最先进来的元素最先被处理。\n- 常用操作：enqueue（入队）、dequeue（出队）、peek（查看队首元素）。\n\n### 性能：\n- 入队（enqueue）和出队（dequeue）：时间复杂度为 O(1)（使用链表或循环数组实现时）。\n- 空间复杂度：与存储的元素数量成正比，为 O(n)。\n\n### 优势：\n- 适用于需要先进先出（FIFO）策略的场景，如任务调度、缓冲区管理等。\n- 操作简单，入队和出队操作效率高。\n\n### 劣势：\n- 访问非队首元素效率低，需要遍历。\n\n## PriorityQueue\n\n### 特点：\n- 元素按照优先级顺序进行出队，优先级高的元素先出队。\n- 常用操作：insert（插入元素）、remove（移除元素）、peek（查看优先级最高的元素）。\n\n### 性能：\n- 插入（insert）：时间复杂度为 O(log n)（使用二叉堆实现时）。\n- 删除（remove）：时间复杂度为 O(log n)（删除优先级最高的元素）。\n- 查看优先级最高元素（peek）：时间复杂度为 O(1)。\n\n### 优势：\n- 适用于需要动态管理元素优先级的场景，如任务调度、路径规划（如Dijkstra算法）、事件驱动模拟等。\n- 可以快速获取和删除优先级最高的元素。\n\n### 劣势：\n- 插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。\n- 需要维护优先级，内存开销可能较大。\n\n## 总结\n\n- Stack：适用于需要 LIFO 策略的场景，入栈和出栈操作效率高（O(1)），但访问非栈顶元素效率低。\n- Queue：适用于需要 FIFO 策略的场景，入队和出队操作效率高（O(1)），但访问非队首元素效率低。\n- PriorityQueue：适用于需要根据优先级动态管理元素的场景，可以快速获取和删除优先级最高的元素（O(log n)），但插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。\n","slug":"高级算法/队栈","published":1,"date":"2024-07-12T08:30:12.525Z","updated":"2024-07-12T08:38:38.483Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlj000cha8aahh4avnf","content":"<h2 id=\"Stack\">Stack</h2>\n<h3 id=\"特点：\">特点：</h3>\n<ul>\n<li>LIFO（Last In, First Out）：最后进来的元素最先被处理。</li>\n<li>常用操作：push（入栈）、pop（出栈）、peek（查看栈顶元素）。</li>\n</ul>\n<h3 id=\"性能：\">性能：</h3>\n<ul>\n<li>入栈（push）和出栈（pop）：时间复杂度为 O(1)。</li>\n<li>空间复杂度：与存储的元素数量成正比，为 O(n)。</li>\n</ul>\n<h3 id=\"优势：\">优势：</h3>\n<ul>\n<li>操作简单，适用于需要后进先出（LIFO）策略的场景，如函数调用栈、表达式求值等。</li>\n<li>内存使用效率高。</li>\n</ul>\n<h3 id=\"劣势：\">劣势：</h3>\n<ul>\n<li>访问非栈顶元素效率低，需要遍历。</li>\n</ul>\n<h2 id=\"Queue\">Queue</h2>\n<h3 id=\"特点：-2\">特点：</h3>\n<ul>\n<li>FIFO（First In, First Out）：最先进来的元素最先被处理。</li>\n<li>常用操作：enqueue（入队）、dequeue（出队）、peek（查看队首元素）。</li>\n</ul>\n<h3 id=\"性能：-2\">性能：</h3>\n<ul>\n<li>入队（enqueue）和出队（dequeue）：时间复杂度为 O(1)（使用链表或循环数组实现时）。</li>\n<li>空间复杂度：与存储的元素数量成正比，为 O(n)。</li>\n</ul>\n<h3 id=\"优势：-2\">优势：</h3>\n<ul>\n<li>适用于需要先进先出（FIFO）策略的场景，如任务调度、缓冲区管理等。</li>\n<li>操作简单，入队和出队操作效率高。</li>\n</ul>\n<h3 id=\"劣势：-2\">劣势：</h3>\n<ul>\n<li>访问非队首元素效率低，需要遍历。</li>\n</ul>\n<h2 id=\"PriorityQueue\">PriorityQueue</h2>\n<h3 id=\"特点：-3\">特点：</h3>\n<ul>\n<li>元素按照优先级顺序进行出队，优先级高的元素先出队。</li>\n<li>常用操作：insert（插入元素）、remove（移除元素）、peek（查看优先级最高的元素）。</li>\n</ul>\n<h3 id=\"性能：-3\">性能：</h3>\n<ul>\n<li>插入（insert）：时间复杂度为 O(log n)（使用二叉堆实现时）。</li>\n<li>删除（remove）：时间复杂度为 O(log n)（删除优先级最高的元素）。</li>\n<li>查看优先级最高元素（peek）：时间复杂度为 O(1)。</li>\n</ul>\n<h3 id=\"优势：-3\">优势：</h3>\n<ul>\n<li>适用于需要动态管理元素优先级的场景，如任务调度、路径规划（如Dijkstra算法）、事件驱动模拟等。</li>\n<li>可以快速获取和删除优先级最高的元素。</li>\n</ul>\n<h3 id=\"劣势：-3\">劣势：</h3>\n<ul>\n<li>插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。</li>\n<li>需要维护优先级，内存开销可能较大。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<ul>\n<li>Stack：适用于需要 LIFO 策略的场景，入栈和出栈操作效率高（O(1)），但访问非栈顶元素效率低。</li>\n<li>Queue：适用于需要 FIFO 策略的场景，入队和出队操作效率高（O(1)），但访问非队首元素效率低。</li>\n<li>PriorityQueue：适用于需要根据优先级动态管理元素的场景，可以快速获取和删除优先级最高的元素（O(log n)），但插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Stack\">Stack</h2>\n<h3 id=\"特点：\">特点：</h3>\n<ul>\n<li>LIFO（Last In, First Out）：最后进来的元素最先被处理。</li>\n<li>常用操作：push（入栈）、pop（出栈）、peek（查看栈顶元素）。</li>\n</ul>\n<h3 id=\"性能：\">性能：</h3>\n<ul>\n<li>入栈（push）和出栈（pop）：时间复杂度为 O(1)。</li>\n<li>空间复杂度：与存储的元素数量成正比，为 O(n)。</li>\n</ul>\n<h3 id=\"优势：\">优势：</h3>\n<ul>\n<li>操作简单，适用于需要后进先出（LIFO）策略的场景，如函数调用栈、表达式求值等。</li>\n<li>内存使用效率高。</li>\n</ul>\n<h3 id=\"劣势：\">劣势：</h3>\n<ul>\n<li>访问非栈顶元素效率低，需要遍历。</li>\n</ul>\n<h2 id=\"Queue\">Queue</h2>\n<h3 id=\"特点：-2\">特点：</h3>\n<ul>\n<li>FIFO（First In, First Out）：最先进来的元素最先被处理。</li>\n<li>常用操作：enqueue（入队）、dequeue（出队）、peek（查看队首元素）。</li>\n</ul>\n<h3 id=\"性能：-2\">性能：</h3>\n<ul>\n<li>入队（enqueue）和出队（dequeue）：时间复杂度为 O(1)（使用链表或循环数组实现时）。</li>\n<li>空间复杂度：与存储的元素数量成正比，为 O(n)。</li>\n</ul>\n<h3 id=\"优势：-2\">优势：</h3>\n<ul>\n<li>适用于需要先进先出（FIFO）策略的场景，如任务调度、缓冲区管理等。</li>\n<li>操作简单，入队和出队操作效率高。</li>\n</ul>\n<h3 id=\"劣势：-2\">劣势：</h3>\n<ul>\n<li>访问非队首元素效率低，需要遍历。</li>\n</ul>\n<h2 id=\"PriorityQueue\">PriorityQueue</h2>\n<h3 id=\"特点：-3\">特点：</h3>\n<ul>\n<li>元素按照优先级顺序进行出队，优先级高的元素先出队。</li>\n<li>常用操作：insert（插入元素）、remove（移除元素）、peek（查看优先级最高的元素）。</li>\n</ul>\n<h3 id=\"性能：-3\">性能：</h3>\n<ul>\n<li>插入（insert）：时间复杂度为 O(log n)（使用二叉堆实现时）。</li>\n<li>删除（remove）：时间复杂度为 O(log n)（删除优先级最高的元素）。</li>\n<li>查看优先级最高元素（peek）：时间复杂度为 O(1)。</li>\n</ul>\n<h3 id=\"优势：-3\">优势：</h3>\n<ul>\n<li>适用于需要动态管理元素优先级的场景，如任务调度、路径规划（如Dijkstra算法）、事件驱动模拟等。</li>\n<li>可以快速获取和删除优先级最高的元素。</li>\n</ul>\n<h3 id=\"劣势：-3\">劣势：</h3>\n<ul>\n<li>插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。</li>\n<li>需要维护优先级，内存开销可能较大。</li>\n</ul>\n<h2 id=\"总结\">总结</h2>\n<ul>\n<li>Stack：适用于需要 LIFO 策略的场景，入栈和出栈操作效率高（O(1)），但访问非栈顶元素效率低。</li>\n<li>Queue：适用于需要 FIFO 策略的场景，入队和出队操作效率高（O(1)），但访问非队首元素效率低。</li>\n<li>PriorityQueue：适用于需要根据优先级动态管理元素的场景，可以快速获取和删除优先级最高的元素（O(log n)），但插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。</li>\n</ul>\n"},{"title":"高级算法目录","_content":"## 高级算法目录\n```\nGraph Theory (BFS, DFS, Biconnectivity)\nShortest Path (Djikstra, Bellman, DAG, All-pairs)\nPattern Matchings (KMP, Bayers Moore)\n```\n### 1.1. BFS (Breadth-First Search)\n\n广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。\n\n**实现步骤：**\n1. 创建一个空队列 `queue` 和一个空集合 `visited`。\n2. 将起始节点放入队列和访问集合中。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中的节点，将其标记为已访问。\n   - 将所有未访问过的邻居节点加入队列和访问集合。\n\n\n### 1.2. DFS (Depth-First Search)\n\n深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。\n\n**实现步骤：**\n1. 创建一个空集合 `visited` 来记录访问过的节点。\n2. 从起始节点开始调用递归函数 `dfs`：\n   - 将当前节点标记为已访问。\n   - 对于当前节点的每个未访问的邻居节点，递归调用 `dfs` 函数。\n\n## 2. Shortest Path Algorithms\n\n\n### 2.1. Dijkstra\n\nDijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。\n\n**实现步骤：**\n1. 创建一个优先队列 `pq` 和距离字典 `distances`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 将起始节点和距离 0 放入队列。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中距离最小的节点。\n   - 对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。\n\n---\n\n### 2.2. Bellman-Ford\n\nBellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。\n\n**实现步骤：**\n1. 创建距离字典 `distance`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 进行 |V|-1 次迭代，每次迭代遍历所有边：\n   - 对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。\n3. 再次遍历所有边，检查是否存在负权环。\n\n## 3. Pattern Matching Algorithms\n\n\n### 3.1. KMP (Knuth-Morris-Pratt)\n\nKMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。\n\n**实现步骤：**\n1. 构建部分匹配表 `lps`，用于指示在匹配失败时模式串应移动的位置。\n2. 使用两个指针 i 和 j 分别遍历文本和模式串：\n   - 如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。\n   - 如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。\n   - 如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。\n\n\n\n### 3.2. Boyer-Moore\n\nBoyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。\n\n**实现步骤：**\n1. 构建字符到最后出现位置的映射表 `last`。\n2. 使用两个指针 s 和 j 分别遍历文本和模式串：\n   - 从右向左比较模式串和文本，当匹配失败时根据 `last` 表跳过一定的字符。\n   - 如果完全匹配，记录匹配的起始位置并移动 s。\n   - 如果部分匹配但未完全匹配，根据 `last` 表调整 j 的位置。\n\n这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。\n","source":"_posts/高级算法/高级算法目录.md","raw":"---\ntitle: 高级算法目录\n---\n## 高级算法目录\n```\nGraph Theory (BFS, DFS, Biconnectivity)\nShortest Path (Djikstra, Bellman, DAG, All-pairs)\nPattern Matchings (KMP, Bayers Moore)\n```\n### 1.1. BFS (Breadth-First Search)\n\n广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。\n\n**实现步骤：**\n1. 创建一个空队列 `queue` 和一个空集合 `visited`。\n2. 将起始节点放入队列和访问集合中。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中的节点，将其标记为已访问。\n   - 将所有未访问过的邻居节点加入队列和访问集合。\n\n\n### 1.2. DFS (Depth-First Search)\n\n深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。\n\n**实现步骤：**\n1. 创建一个空集合 `visited` 来记录访问过的节点。\n2. 从起始节点开始调用递归函数 `dfs`：\n   - 将当前节点标记为已访问。\n   - 对于当前节点的每个未访问的邻居节点，递归调用 `dfs` 函数。\n\n## 2. Shortest Path Algorithms\n\n\n### 2.1. Dijkstra\n\nDijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。\n\n**实现步骤：**\n1. 创建一个优先队列 `pq` 和距离字典 `distances`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 将起始节点和距离 0 放入队列。\n3. 当队列不为空时，重复以下步骤：\n   - 弹出队列中距离最小的节点。\n   - 对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。\n\n---\n\n### 2.2. Bellman-Ford\n\nBellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。\n\n**实现步骤：**\n1. 创建距离字典 `distance`，初始化起始节点的距离为 0，其余节点为无穷大。\n2. 进行 |V|-1 次迭代，每次迭代遍历所有边：\n   - 对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。\n3. 再次遍历所有边，检查是否存在负权环。\n\n## 3. Pattern Matching Algorithms\n\n\n### 3.1. KMP (Knuth-Morris-Pratt)\n\nKMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。\n\n**实现步骤：**\n1. 构建部分匹配表 `lps`，用于指示在匹配失败时模式串应移动的位置。\n2. 使用两个指针 i 和 j 分别遍历文本和模式串：\n   - 如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。\n   - 如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。\n   - 如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。\n\n\n\n### 3.2. Boyer-Moore\n\nBoyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。\n\n**实现步骤：**\n1. 构建字符到最后出现位置的映射表 `last`。\n2. 使用两个指针 s 和 j 分别遍历文本和模式串：\n   - 从右向左比较模式串和文本，当匹配失败时根据 `last` 表跳过一定的字符。\n   - 如果完全匹配，记录匹配的起始位置并移动 s。\n   - 如果部分匹配但未完全匹配，根据 `last` 表调整 j 的位置。\n\n这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。\n","slug":"高级算法/高级算法目录","published":1,"date":"2024-07-10T10:07:16.811Z","updated":"2024-07-10T10:08:51.419Z","comments":1,"layout":"post","photos":[],"_id":"clyjrdtlk000dha8a7aef0uj1","content":"<h2 id=\"高级算法目录\">高级算法目录</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Graph Theory (BFS, DFS, Biconnectivity)</span><br><span class=\"line\">Shortest Path (Djikstra, Bellman, DAG, All-pairs)</span><br><span class=\"line\">Pattern Matchings (KMP, Bayers Moore)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-BFS-Breadth-First-Search\">1.1. BFS (Breadth-First Search)</h3>\n<p>广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空队列 <code>queue</code> 和一个空集合 <code>visited</code>。</li>\n<li>将起始节点放入队列和访问集合中。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中的节点，将其标记为已访问。</li>\n<li>将所有未访问过的邻居节点加入队列和访问集合。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-2-DFS-Depth-First-Search\">1.2. DFS (Depth-First Search)</h3>\n<p>深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空集合 <code>visited</code> 来记录访问过的节点。</li>\n<li>从起始节点开始调用递归函数 <code>dfs</code>：\n<ul>\n<li>将当前节点标记为已访问。</li>\n<li>对于当前节点的每个未访问的邻居节点，递归调用 <code>dfs</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-Shortest-Path-Algorithms\">2. Shortest Path Algorithms</h2>\n<h3 id=\"2-1-Dijkstra\">2.1. Dijkstra</h3>\n<p>Dijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个优先队列 <code>pq</code> 和距离字典 <code>distances</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>将起始节点和距离 0 放入队列。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中距离最小的节点。</li>\n<li>对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-2-Bellman-Ford\">2.2. Bellman-Ford</h3>\n<p>Bellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建距离字典 <code>distance</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>进行 |V|-1 次迭代，每次迭代遍历所有边：\n<ul>\n<li>对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。</li>\n</ul>\n</li>\n<li>再次遍历所有边，检查是否存在负权环。</li>\n</ol>\n<h2 id=\"3-Pattern-Matching-Algorithms\">3. Pattern Matching Algorithms</h2>\n<h3 id=\"3-1-KMP-Knuth-Morris-Pratt\">3.1. KMP (Knuth-Morris-Pratt)</h3>\n<p>KMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建部分匹配表 <code>lps</code>，用于指示在匹配失败时模式串应移动的位置。</li>\n<li>使用两个指针 i 和 j 分别遍历文本和模式串：\n<ul>\n<li>如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。</li>\n<li>如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。</li>\n<li>如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-Boyer-Moore\">3.2. Boyer-Moore</h3>\n<p>Boyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建字符到最后出现位置的映射表 <code>last</code>。</li>\n<li>使用两个指针 s 和 j 分别遍历文本和模式串：\n<ul>\n<li>从右向左比较模式串和文本，当匹配失败时根据 <code>last</code> 表跳过一定的字符。</li>\n<li>如果完全匹配，记录匹配的起始位置并移动 s。</li>\n<li>如果部分匹配但未完全匹配，根据 <code>last</code> 表调整 j 的位置。</li>\n</ul>\n</li>\n</ol>\n<p>这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。</p>\n","excerpt":"","more":"<h2 id=\"高级算法目录\">高级算法目录</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Graph Theory (BFS, DFS, Biconnectivity)</span><br><span class=\"line\">Shortest Path (Djikstra, Bellman, DAG, All-pairs)</span><br><span class=\"line\">Pattern Matchings (KMP, Bayers Moore)</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-BFS-Breadth-First-Search\">1.1. BFS (Breadth-First Search)</h3>\n<p>广度优先搜索（BFS）是一种图搜索算法，从起始节点开始，逐层向外扩展，访问所有相邻节点。BFS 使用队列来跟踪要访问的节点顺序，适用于寻找最短路径（在无权图中）和检测图的连通性。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空队列 <code>queue</code> 和一个空集合 <code>visited</code>。</li>\n<li>将起始节点放入队列和访问集合中。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中的节点，将其标记为已访问。</li>\n<li>将所有未访问过的邻居节点加入队列和访问集合。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-2-DFS-Depth-First-Search\">1.2. DFS (Depth-First Search)</h3>\n<p>深度优先搜索（DFS）是一种图搜索算法，从起始节点开始，沿着一个分支深入，直到不能继续为止，然后回溯并继续搜索未访问的节点。DFS 使用栈来实现递归，适用于检测环、拓扑排序等。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个空集合 <code>visited</code> 来记录访问过的节点。</li>\n<li>从起始节点开始调用递归函数 <code>dfs</code>：\n<ul>\n<li>将当前节点标记为已访问。</li>\n<li>对于当前节点的每个未访问的邻居节点，递归调用 <code>dfs</code> 函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-Shortest-Path-Algorithms\">2. Shortest Path Algorithms</h2>\n<h3 id=\"2-1-Dijkstra\">2.1. Dijkstra</h3>\n<p>Dijkstra 算法用于计算单源最短路径，适用于边权重非负的图。它使用优先队列来选择当前最短路径的节点，逐步更新其邻居的最短路径。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建一个优先队列 <code>pq</code> 和距离字典 <code>distances</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>将起始节点和距离 0 放入队列。</li>\n<li>当队列不为空时，重复以下步骤：\n<ul>\n<li>弹出队列中距离最小的节点。</li>\n<li>对于该节点的每个邻居节点，如果通过当前节点到达该邻居节点的路径距离更短，则更新距离并将其加入队列。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-2-Bellman-Ford\">2.2. Bellman-Ford</h3>\n<p>Bellman-Ford 算法用于计算单源最短路径，适用于包含负权边的图。它通过反复松弛所有边，更新最短路径，最多进行 |V|-1 次迭代。它还能检测负权环。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>创建距离字典 <code>distance</code>，初始化起始节点的距离为 0，其余节点为无穷大。</li>\n<li>进行 |V|-1 次迭代，每次迭代遍历所有边：\n<ul>\n<li>对于每条边 (u, v) 权重为 w，如果通过节点 u 到节点 v 的路径距离更短，则更新距离。</li>\n</ul>\n</li>\n<li>再次遍历所有边，检查是否存在负权环。</li>\n</ol>\n<h2 id=\"3-Pattern-Matching-Algorithms\">3. Pattern Matching Algorithms</h2>\n<h3 id=\"3-1-KMP-Knuth-Morris-Pratt\">3.1. KMP (Knuth-Morris-Pratt)</h3>\n<p>KMP 算法用于字符串模式匹配，通过预处理模式串构建部分匹配表，从而在匹配过程中避免重复扫描文本。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建部分匹配表 <code>lps</code>，用于指示在匹配失败时模式串应移动的位置。</li>\n<li>使用两个指针 i 和 j 分别遍历文本和模式串：\n<ul>\n<li>如果匹配成功（text[i] == pattern[j]），则同时向前移动 i 和 j。</li>\n<li>如果 j 达到模式串末尾，说明找到了匹配，记录匹配的起始位置。</li>\n<li>如果匹配失败（text[i] != pattern[j]），根据部分匹配表移动模式串的位置 j。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-2-Boyer-Moore\">3.2. Boyer-Moore</h3>\n<p>Boyer-Moore 算法是另一种字符串模式匹配算法，通过从右向左匹配和使用跳跃表显著减少比较次数，提高匹配效率。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>构建字符到最后出现位置的映射表 <code>last</code>。</li>\n<li>使用两个指针 s 和 j 分别遍历文本和模式串：\n<ul>\n<li>从右向左比较模式串和文本，当匹配失败时根据 <code>last</code> 表跳过一定的字符。</li>\n<li>如果完全匹配，记录匹配的起始位置并移动 s。</li>\n<li>如果部分匹配但未完全匹配，根据 <code>last</code> 表调整 j 的位置。</li>\n</ul>\n</li>\n</ol>\n<p>这些算法在图论、路径查找和字符串模式匹配领域中具有重要应用，能够有效解决各种复杂问题。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}