## Stack

### 特点：
- LIFO（Last In, First Out）：最后进来的元素最先被处理。
- 常用操作：push（入栈）、pop（出栈）、peek（查看栈顶元素）。

### 性能：
- 入栈（push）和出栈（pop）：时间复杂度为 O(1)。
- 空间复杂度：与存储的元素数量成正比，为 O(n)。

### 优势：
- 操作简单，适用于需要后进先出（LIFO）策略的场景，如函数调用栈、表达式求值等。
- 内存使用效率高。

### 劣势：
- 访问非栈顶元素效率低，需要遍历。

## Queue

### 特点：
- FIFO（First In, First Out）：最先进来的元素最先被处理。
- 常用操作：enqueue（入队）、dequeue（出队）、peek（查看队首元素）。

### 性能：
- 入队（enqueue）和出队（dequeue）：时间复杂度为 O(1)（使用链表或循环数组实现时）。
- 空间复杂度：与存储的元素数量成正比，为 O(n)。

### 优势：
- 适用于需要先进先出（FIFO）策略的场景，如任务调度、缓冲区管理等。
- 操作简单，入队和出队操作效率高。

### 劣势：
- 访问非队首元素效率低，需要遍历。

## PriorityQueue

### 特点：
- 元素按照优先级顺序进行出队，优先级高的元素先出队。
- 常用操作：insert（插入元素）、remove（移除元素）、peek（查看优先级最高的元素）。

### 性能：
- 插入（insert）：时间复杂度为 O(log n)（使用二叉堆实现时）。
- 删除（remove）：时间复杂度为 O(log n)（删除优先级最高的元素）。
- 查看优先级最高元素（peek）：时间复杂度为 O(1)。

### 优势：
- 适用于需要动态管理元素优先级的场景，如任务调度、路径规划（如Dijkstra算法）、事件驱动模拟等。
- 可以快速获取和删除优先级最高的元素。

### 劣势：
- 插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。
- 需要维护优先级，内存开销可能较大。

## 总结

- Stack：适用于需要 LIFO 策略的场景，入栈和出栈操作效率高（O(1)），但访问非栈顶元素效率低。
- Queue：适用于需要 FIFO 策略的场景，入队和出队操作效率高（O(1)），但访问非队首元素效率低。
- PriorityQueue：适用于需要根据优先级动态管理元素的场景，可以快速获取和删除优先级最高的元素（O(log n)），但插入和删除操作比 Stack 和 Queue 要复杂，时间复杂度较高。
